"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fullcalendar+timegrid@6.1.18_@fullcalendar+core@6.1.18";
exports.ids = ["vendor-chunks/@fullcalendar+timegrid@6.1.18_@fullcalendar+core@6.1.18"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@fullcalendar+timegrid@6.1.18_@fullcalendar+core@6.1.18/node_modules/@fullcalendar/timegrid/index.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@fullcalendar+timegrid@6.1.18_@fullcalendar+core@6.1.18/node_modules/@fullcalendar/timegrid/index.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/index.js */ \"(ssr)/./node_modules/.pnpm/@fullcalendar+core@6.1.18/node_modules/@fullcalendar/core/index.js\");\n/* harmony import */ var _internal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal.js */ \"(ssr)/./node_modules/.pnpm/@fullcalendar+timegrid@6.1.18_@fullcalendar+core@6.1.18/node_modules/@fullcalendar/timegrid/internal.js\");\n\n\n\n\n\n\nconst OPTION_REFINERS = {\n    allDaySlot: Boolean,\n};\n\nvar index = (0,_fullcalendar_core_index_js__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n    name: '@fullcalendar/timegrid',\n    initialView: 'timeGridWeek',\n    optionRefiners: OPTION_REFINERS,\n    views: {\n        timeGrid: {\n            component: _internal_js__WEBPACK_IMPORTED_MODULE_1__.DayTimeColsView,\n            usesMinMaxTime: true,\n            allDaySlot: true,\n            slotDuration: '00:30:00',\n            slotEventOverlap: true, // a bad name. confused with overlap/constraint system\n        },\n        timeGridDay: {\n            type: 'timeGrid',\n            duration: { days: 1 },\n        },\n        timeGridWeek: {\n            type: 'timeGrid',\n            duration: { weeks: 1 },\n        },\n    },\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZ1bGxjYWxlbmRhcit0aW1lZ3JpZEA2LjEuMThfQGZ1bGxjYWxlbmRhcitjb3JlQDYuMS4xOC9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkQ7QUFDWDtBQUNSO0FBQ0Y7QUFDSzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBLFlBQVkseUVBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7O0FBRTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtY2FsZW5kYXItY3Vyc29yLWdwdDUvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZ1bGxjYWxlbmRhcit0aW1lZ3JpZEA2LjEuMThfQGZ1bGxjYWxlbmRhcitjb3JlQDYuMS4xOC9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9pbmRleC5qcz83NTg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBEYXlUaW1lQ29sc1ZpZXcgfSBmcm9tICcuL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcyc7XG5cbmNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBhbGxEYXlTbG90OiBCb29sZWFuLFxufTtcblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci90aW1lZ3JpZCcsXG4gICAgaW5pdGlhbFZpZXc6ICd0aW1lR3JpZFdlZWsnLFxuICAgIG9wdGlvblJlZmluZXJzOiBPUFRJT05fUkVGSU5FUlMsXG4gICAgdmlld3M6IHtcbiAgICAgICAgdGltZUdyaWQ6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogRGF5VGltZUNvbHNWaWV3LFxuICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHRydWUsXG4gICAgICAgICAgICBhbGxEYXlTbG90OiB0cnVlLFxuICAgICAgICAgICAgc2xvdER1cmF0aW9uOiAnMDA6MzA6MDAnLFxuICAgICAgICAgICAgc2xvdEV2ZW50T3ZlcmxhcDogdHJ1ZSwgLy8gYSBiYWQgbmFtZS4gY29uZnVzZWQgd2l0aCBvdmVybGFwL2NvbnN0cmFpbnQgc3lzdGVtXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVHcmlkRGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAndGltZUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxuICAgICAgICB9LFxuICAgICAgICB0aW1lR3JpZFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICd0aW1lR3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@fullcalendar+timegrid@6.1.18_@fullcalendar+core@6.1.18/node_modules/@fullcalendar/timegrid/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@fullcalendar+timegrid@6.1.18_@fullcalendar+core@6.1.18/node_modules/@fullcalendar/timegrid/internal.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@fullcalendar+timegrid@6.1.18_@fullcalendar+core@6.1.18/node_modules/@fullcalendar/timegrid/internal.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DayTimeCols: () => (/* binding */ DayTimeCols),\n/* harmony export */   DayTimeColsSlicer: () => (/* binding */ DayTimeColsSlicer),\n/* harmony export */   DayTimeColsView: () => (/* binding */ DayTimeColsView),\n/* harmony export */   TimeCols: () => (/* binding */ TimeCols),\n/* harmony export */   TimeColsSlatsCoords: () => (/* binding */ TimeColsSlatsCoords),\n/* harmony export */   TimeColsView: () => (/* binding */ TimeColsView),\n/* harmony export */   buildDayRanges: () => (/* binding */ buildDayRanges),\n/* harmony export */   buildSlatMetas: () => (/* binding */ buildSlatMetas),\n/* harmony export */   buildTimeColsModel: () => (/* binding */ buildTimeColsModel)\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/core/internal.js */ \"(ssr)/./node_modules/.pnpm/@fullcalendar+core@6.1.18/node_modules/@fullcalendar/core/internal-common.js\");\n/* harmony import */ var _fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/core/preact.js */ \"(ssr)/./node_modules/.pnpm/preact@10.12.1/node_modules/preact/dist/preact.mjs\");\n/* harmony import */ var _fullcalendar_daygrid_internal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @fullcalendar/daygrid/internal.js */ \"(ssr)/./node_modules/.pnpm/@fullcalendar+daygrid@6.1.18_@fullcalendar+core@6.1.18/node_modules/@fullcalendar/daygrid/internal.js\");\n\n\n\n\nclass AllDaySplitter extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.aW {\n    getKeyInfo() {\n        return {\n            allDay: {},\n            timed: {},\n        };\n    }\n    getKeysForDateSpan(dateSpan) {\n        if (dateSpan.allDay) {\n            return ['allDay'];\n        }\n        return ['timed'];\n    }\n    getKeysForEventDef(eventDef) {\n        if (!eventDef.allDay) {\n            return ['timed'];\n        }\n        if ((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bN)(eventDef)) {\n            return ['timed', 'allDay'];\n        }\n        return ['allDay'];\n    }\n}\n\nconst DEFAULT_SLAT_LABEL_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    hour: 'numeric',\n    minute: '2-digit',\n    omitZeroMinute: true,\n    meridiem: 'short',\n});\nfunction TimeColsAxisCell(props) {\n    let classNames = [\n        'fc-timegrid-slot',\n        'fc-timegrid-slot-label',\n        props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor',\n    ];\n    return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.V.Consumer, null, (context) => {\n        if (!props.isLabeled) {\n            return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", { className: classNames.join(' '), \"data-time\": props.isoTimeStr }));\n        }\n        let { dateEnv, options, viewApi } = context;\n        let labelFormat = // TODO: fully pre-parse\n         options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT :\n            Array.isArray(options.slotLabelFormat) ? (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)(options.slotLabelFormat[0]) :\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)(options.slotLabelFormat);\n        let renderProps = {\n            level: 0,\n            time: props.time,\n            date: dateEnv.toDate(props.date),\n            view: viewApi,\n            text: dateEnv.format(props.date, labelFormat),\n        };\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.C, { elTag: \"td\", elClasses: classNames, elAttrs: {\n                'data-time': props.isoTimeStr,\n            }, renderProps: renderProps, generatorName: \"slotLabelContent\", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\" },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, { elTag: \"div\", elClasses: [\n                    'fc-timegrid-slot-label-cushion',\n                    'fc-scrollgrid-shrink-cushion',\n                ] })))));\n    }));\n}\nfunction renderInnerContent(props) {\n    return props.text;\n}\n\nclass TimeBodyAxis extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        return this.props.slatMetas.map((slatMeta) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", { key: slatMeta.key },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsAxisCell, Object.assign({}, slatMeta)))));\n    }\n}\n\nconst DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({ week: 'short' });\nconst AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\nclass TimeColsView extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc {\n    constructor() {\n        super(...arguments);\n        this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n        this.headerElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.scrollerElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.state = {\n            slatCoords: null,\n        };\n        this.handleScrollTopRequest = (scrollTop) => {\n            let scrollerEl = this.scrollerElRef.current;\n            if (scrollerEl) { // TODO: not sure how this could ever be null. weirdness with the reducer\n                scrollerEl.scrollTop = scrollTop;\n            }\n        };\n        /* Header Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/\n        this.renderHeadAxis = (rowKey, frameHeight = '') => {\n            let { options } = this.context;\n            let { dateProfile } = this.props;\n            let range = dateProfile.renderRange;\n            let dayCnt = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bj)(range.start, range.end);\n            // only do in day views (to avoid doing in week views that dont need it)\n            let navLinkAttrs = (dayCnt === 1)\n                ? (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a_)(this.context, range.start, 'week')\n                : {};\n            if (options.weekNumbers && rowKey === 'day') {\n                return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cn, { elTag: \"th\", elClasses: [\n                        'fc-timegrid-axis',\n                        'fc-scrollgrid-shrink',\n                    ], elAttrs: {\n                        'aria-hidden': true,\n                    }, date: range.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }, (InnerContent) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: [\n                        'fc-timegrid-axis-frame',\n                        'fc-scrollgrid-shrink-frame',\n                        'fc-timegrid-axis-frame-liquid',\n                    ].join(' '), style: { height: frameHeight } },\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, { elTag: \"a\", elClasses: [\n                            'fc-timegrid-axis-cushion',\n                            'fc-scrollgrid-shrink-cushion',\n                            'fc-scrollgrid-sync-inner',\n                        ], elAttrs: navLinkAttrs })))));\n            }\n            return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", { \"aria-hidden\": true, className: \"fc-timegrid-axis\" },\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-axis-frame\", style: { height: frameHeight } })));\n        };\n        /* Table Component Render Methods\n        ------------------------------------------------------------------------------------------------------------------*/\n        // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n        // but DayGrid still needs to have classNames on inner elements in order to measure.\n        this.renderTableRowAxis = (rowHeight) => {\n            let { options, viewApi } = this.context;\n            let renderProps = {\n                text: options.allDayText,\n                view: viewApi,\n            };\n            return (\n            // TODO: make reusable hook. used in list view too\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.C, { elTag: \"td\", elClasses: [\n                    'fc-timegrid-axis',\n                    'fc-scrollgrid-shrink',\n                ], elAttrs: {\n                    'aria-hidden': true,\n                }, renderProps: renderProps, generatorName: \"allDayContent\", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, (InnerContent) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: [\n                    'fc-timegrid-axis-frame',\n                    'fc-scrollgrid-shrink-frame',\n                    rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : '',\n                ].join(' '), style: { height: rowHeight } },\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, { elTag: \"span\", elClasses: [\n                        'fc-timegrid-axis-cushion',\n                        'fc-scrollgrid-shrink-cushion',\n                        'fc-scrollgrid-sync-inner',\n                    ] })))));\n        };\n        this.handleSlatCoords = (slatCoords) => {\n            this.setState({ slatCoords });\n        };\n    }\n    // rendering\n    // ----------------------------------------------------------------------------------------------------\n    renderSimpleLayout(headerRowContent, allDayContent, timeContent) {\n        let { context, props } = this;\n        let sections = [];\n        let stickyHeaderDates = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ca)(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: 'header',\n                key: 'header',\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: 'fc-col-header',\n                    rowContent: headerRowContent,\n                },\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: 'body',\n                key: 'all-day',\n                chunk: { content: allDayContent },\n            });\n            sections.push({\n                type: 'body',\n                key: 'all-day-divider',\n                outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", { role: \"presentation\", className: \"fc-scrollgrid-section\" },\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", { className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded') }))),\n            });\n        }\n        sections.push({\n            type: 'body',\n            key: 'body',\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunk: {\n                scrollerElRef: this.scrollerElRef,\n                content: timeContent,\n            },\n        });\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cq, { elRef: this.rootElRef, elClasses: ['fc-timegrid'], viewSpec: context.viewSpec },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bZ, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [{ width: 'shrink' }], sections: sections })));\n    }\n    renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n        let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error('No ScrollGrid implementation');\n        }\n        let { context, props } = this;\n        let stickyHeaderDates = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ca)(context.options);\n        let stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.c9)(context.options);\n        let sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: 'header',\n                key: 'header',\n                isSticky: stickyHeaderDates,\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: 'axis',\n                        rowContent: (arg) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", { role: \"presentation\" }, this.renderHeadAxis('day', arg.rowSyncHeights[0]))),\n                    },\n                    {\n                        key: 'cols',\n                        elRef: this.headerElRef,\n                        tableClassName: 'fc-col-header',\n                        rowContent: headerRowContent,\n                    },\n                ],\n            });\n        }\n        if (allDayContent) {\n            sections.push({\n                type: 'body',\n                key: 'all-day',\n                syncRowHeights: true,\n                chunks: [\n                    {\n                        key: 'axis',\n                        rowContent: (contentArg) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", { role: \"presentation\" }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))),\n                    },\n                    {\n                        key: 'cols',\n                        content: allDayContent,\n                    },\n                ],\n            });\n            sections.push({\n                key: 'all-day-divider',\n                type: 'body',\n                outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", { role: \"presentation\", className: \"fc-scrollgrid-section\" },\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", { colSpan: 2, className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded') }))),\n            });\n        }\n        let isNowIndicator = context.options.nowIndicator;\n        sections.push({\n            type: 'body',\n            key: 'body',\n            liquid: true,\n            expandRows: Boolean(context.options.expandRows),\n            chunks: [\n                {\n                    key: 'axis',\n                    content: (arg) => (\n                    // TODO: make this now-indicator arrow more DRY with TimeColsContent\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-axis-chunk\" },\n                        (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", { \"aria-hidden\": true, style: { height: arg.expandRows ? arg.clientHeight : '' } },\n                            arg.tableColGroupNode,\n                            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null,\n                                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeBodyAxis, { slatMetas: slatMetas }))),\n                        (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-now-indicator-container\" },\n                            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a6, { unit: isNowIndicator ? 'minute' : 'day' /* hacky */ }, (nowDate) => {\n                                let nowIndicatorTop = isNowIndicator &&\n                                    slatCoords &&\n                                    slatCoords.safeComputeTop(nowDate); // might return void\n                                if (typeof nowIndicatorTop === 'number') {\n                                    return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ch, { elClasses: ['fc-timegrid-now-indicator-arrow'], elStyle: { top: nowIndicatorTop }, isAxis: true, date: nowDate }));\n                                }\n                                return null;\n                            })))),\n                },\n                {\n                    key: 'cols',\n                    scrollerElRef: this.scrollerElRef,\n                    content: timeContent,\n                },\n            ],\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                key: 'footer',\n                type: 'footer',\n                isSticky: true,\n                chunks: [\n                    {\n                        key: 'axis',\n                        content: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.c8,\n                    },\n                    {\n                        key: 'cols',\n                        content: _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.c8,\n                    },\n                ],\n            });\n        }\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cq, { elRef: this.rootElRef, elClasses: ['fc-timegrid'], viewSpec: context.viewSpec },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [\n                    { width: 'shrink', cols: [{ width: 'shrink' }] },\n                    { cols: [{ span: colCnt, minWidth: dayMinWidth }] },\n                ], sections: sections })));\n    }\n    /* Dimensions\n    ------------------------------------------------------------------------------------------------------------------*/\n    getAllDayMaxEventProps() {\n        let { dayMaxEvents, dayMaxEventRows } = this.context.options;\n        if (dayMaxEvents === true || dayMaxEventRows === true) { // is auto?\n            dayMaxEvents = undefined;\n            dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n        }\n        return { dayMaxEvents, dayMaxEventRows };\n    }\n}\nfunction renderAllDayInner(renderProps) {\n    return renderProps.text;\n}\n\nclass TimeColsSlatsCoords {\n    constructor(positions, dateProfile, slotDuration) {\n        this.positions = positions;\n        this.dateProfile = dateProfile;\n        this.slotDuration = slotDuration;\n    }\n    safeComputeTop(date) {\n        let { dateProfile } = this;\n        if ((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.G)(dateProfile.currentRange, date)) {\n            let startOfDayDate = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.q)(date);\n            let timeMs = date.valueOf() - startOfDayDate.valueOf();\n            if (timeMs >= (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bq)(dateProfile.slotMinTime) &&\n                timeMs < (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bq)(dateProfile.slotMaxTime)) {\n                return this.computeTimeTop((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(timeMs));\n            }\n        }\n        return null;\n    }\n    // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n    computeDateTop(when, startOfDayDate) {\n        if (!startOfDayDate) {\n            startOfDayDate = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.q)(when);\n        }\n        return this.computeTimeTop((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(when.valueOf() - startOfDayDate.valueOf()));\n    }\n    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n    // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n    // Eventually allow computation with arbirary slat dates.\n    computeTimeTop(duration) {\n        let { positions, dateProfile } = this;\n        let len = positions.els.length;\n        // floating-point value of # of slots covered\n        let slatCoverage = (duration.milliseconds - (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bq)(dateProfile.slotMinTime)) / (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bq)(this.slotDuration);\n        let slatIndex;\n        let slatRemainder;\n        // compute a floating-point number for how many slats should be progressed through.\n        // from 0 to number of slats (inclusive)\n        // constrained because slotMinTime/slotMaxTime might be customized.\n        slatCoverage = Math.max(0, slatCoverage);\n        slatCoverage = Math.min(len, slatCoverage);\n        // an integer index of the furthest whole slat\n        // from 0 to number slats (*exclusive*, so len-1)\n        slatIndex = Math.floor(slatCoverage);\n        slatIndex = Math.min(slatIndex, len - 1);\n        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n        // could be 1.0 if slatCoverage is covering *all* the slots\n        slatRemainder = slatCoverage - slatIndex;\n        return positions.tops[slatIndex] +\n            positions.getHeight(slatIndex) * slatRemainder;\n    }\n}\n\nclass TimeColsSlatsBody extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let { slatElRefs } = props;\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null, props.slatMetas.map((slatMeta, i) => {\n            let renderProps = {\n                time: slatMeta.time,\n                date: context.dateEnv.toDate(slatMeta.date),\n                view: context.viewApi,\n            };\n            return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },\n                props.axis && ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsAxisCell, Object.assign({}, slatMeta))),\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.C, { elTag: \"td\", elClasses: [\n                        'fc-timegrid-slot',\n                        'fc-timegrid-slot-lane',\n                        !slatMeta.isLabeled && 'fc-timegrid-slot-minor',\n                    ], elAttrs: {\n                        'data-time': slatMeta.isoTimeStr,\n                    }, renderProps: renderProps, generatorName: \"slotLaneContent\", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount })));\n        })));\n    }\n}\n\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\nclass TimeColsSlats extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor() {\n        super(...arguments);\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.slatElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cd();\n    }\n    render() {\n        let { props, context } = this;\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { ref: this.rootElRef, className: \"fc-timegrid-slots\" },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", { \"aria-hidden\": true, className: context.theme.getClass('table'), style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth,\n                    height: props.minHeight,\n                } },\n                props.tableColGroupNode /* relies on there only being a single <col> for the axis */,\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas }))));\n    }\n    componentDidMount() {\n        this.updateSizing();\n    }\n    componentDidUpdate() {\n        this.updateSizing();\n    }\n    componentWillUnmount() {\n        if (this.props.onCoords) {\n            this.props.onCoords(null);\n        }\n    }\n    updateSizing() {\n        let { context, props } = this;\n        if (props.onCoords &&\n            props.clientWidth !== null // means sizing has stabilized\n        ) {\n            let rootEl = this.rootElRef.current;\n            if (rootEl.offsetHeight) { // not hidden by css\n                props.onCoords(new TimeColsSlatsCoords(new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b8(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n            }\n        }\n    }\n}\nfunction collectSlatEls(elMap, slatMetas) {\n    return slatMetas.map((slatMeta) => elMap[slatMeta.key]);\n}\n\nfunction splitSegsByCol(segs, colCnt) {\n    let segsByCol = [];\n    let i;\n    for (i = 0; i < colCnt; i += 1) {\n        segsByCol.push([]);\n    }\n    if (segs) {\n        for (i = 0; i < segs.length; i += 1) {\n            segsByCol[segs[i].col].push(segs[i]);\n        }\n    }\n    return segsByCol;\n}\nfunction splitInteractionByCol(ui, colCnt) {\n    let byRow = [];\n    if (!ui) {\n        for (let i = 0; i < colCnt; i += 1) {\n            byRow[i] = null;\n        }\n    }\n    else {\n        for (let i = 0; i < colCnt; i += 1) {\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: [],\n            };\n        }\n        for (let seg of ui.segs) {\n            byRow[seg.col].segs.push(seg);\n        }\n    }\n    return byRow;\n}\n\nclass TimeColMoreLink extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        let { props } = this;\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.co, { elClasses: ['fc-timegrid-more-link'], elStyle: {\n                top: props.top,\n                bottom: props.bottom,\n            }, allDayDate: null, moreCnt: props.hiddenSegs.length, allSegs: props.hiddenSegs, hiddenSegs: props.hiddenSegs, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, todayRange: props.todayRange, popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props), defaultGenerator: renderMoreLinkInner, forceTimed: true }, (InnerContent) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, { elTag: \"div\", elClasses: ['fc-timegrid-more-link-inner', 'fc-sticky'] }))));\n    }\n}\nfunction renderMoreLinkInner(props) {\n    return props.shortText;\n}\n\n// segInputs assumed sorted\nfunction buildPositioning(segInputs, strictOrder, maxStackCnt) {\n    let hierarchy = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.by();\n    if (strictOrder != null) {\n        hierarchy.strictOrder = strictOrder;\n    }\n    if (maxStackCnt != null) {\n        hierarchy.maxStackCnt = maxStackCnt;\n    }\n    let hiddenEntries = hierarchy.addSegs(segInputs);\n    let hiddenGroups = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bC)(hiddenEntries);\n    let web = buildWeb(hierarchy);\n    web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n    let segRects = webToRects(web);\n    return { segRects, hiddenGroups };\n}\nfunction buildWeb(hierarchy) {\n    const { entriesByLevel } = hierarchy;\n    const buildNode = cacheable((level, lateral) => level + ':' + lateral, (level, lateral) => {\n        let siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n        let nextLevelRes = buildNodes(siblingRange, buildNode);\n        let entry = entriesByLevel[level][lateral];\n        return [\n            Object.assign(Object.assign({}, entry), { nextLevelNodes: nextLevelRes[0] }),\n            entry.thickness + nextLevelRes[1], // the pressure builds\n        ];\n    });\n    return buildNodes(entriesByLevel.length\n        ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length }\n        : null, buildNode)[0];\n}\nfunction buildNodes(siblingRange, buildNode) {\n    if (!siblingRange) {\n        return [[], 0];\n    }\n    let { level, lateralStart, lateralEnd } = siblingRange;\n    let lateral = lateralStart;\n    let pairs = [];\n    while (lateral < lateralEnd) {\n        pairs.push(buildNode(level, lateral));\n        lateral += 1;\n    }\n    pairs.sort(cmpDescPressures);\n    return [\n        pairs.map(extractNode),\n        pairs[0][1], // first item's pressure\n    ];\n}\nfunction cmpDescPressures(a, b) {\n    return b[1] - a[1];\n}\nfunction extractNode(a) {\n    return a[0];\n}\nfunction findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n    let { levelCoords, entriesByLevel } = hierarchy;\n    let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n    let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n    let levelCnt = levelCoords.length;\n    let level = subjectLevel;\n    // skip past levels that are too high up\n    for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1)\n        ; // do nothing\n    for (; level < levelCnt; level += 1) {\n        let entries = entriesByLevel[level];\n        let entry;\n        let searchIndex = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bB)(entries, subjectEntry.span.start, _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bA);\n        let lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n        let lateralEnd = lateralStart;\n        while ( // loop through entries that horizontally intersect\n        (entry = entries[lateralEnd]) && // but not past the whole seg list\n            entry.span.start < subjectEntry.span.end) {\n            lateralEnd += 1;\n        }\n        if (lateralStart < lateralEnd) {\n            return { level, lateralStart, lateralEnd };\n        }\n    }\n    return null;\n}\nfunction stretchWeb(topLevelNodes, totalThickness) {\n    const stretchNode = cacheable((node, startCoord, prevThickness) => (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bz)(node), (node, startCoord, prevThickness) => {\n        let { nextLevelNodes, thickness } = node;\n        let allThickness = thickness + prevThickness;\n        let thicknessFraction = thickness / allThickness;\n        let endCoord;\n        let newChildren = [];\n        if (!nextLevelNodes.length) {\n            endCoord = totalThickness;\n        }\n        else {\n            for (let childNode of nextLevelNodes) {\n                if (endCoord === undefined) {\n                    let res = stretchNode(childNode, startCoord, allThickness);\n                    endCoord = res[0];\n                    newChildren.push(res[1]);\n                }\n                else {\n                    let res = stretchNode(childNode, endCoord, 0);\n                    newChildren.push(res[1]);\n                }\n            }\n        }\n        let newThickness = (endCoord - startCoord) * thicknessFraction;\n        return [endCoord - newThickness, Object.assign(Object.assign({}, node), { thickness: newThickness, nextLevelNodes: newChildren })];\n    });\n    return topLevelNodes.map((node) => stretchNode(node, 0, 0)[1]);\n}\n// not sorted in any particular order\nfunction webToRects(topLevelNodes) {\n    let rects = [];\n    const processNode = cacheable((node, levelCoord, stackDepth) => (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bz)(node), (node, levelCoord, stackDepth) => {\n        let rect = Object.assign(Object.assign({}, node), { levelCoord,\n            stackDepth, stackForward: 0 });\n        rects.push(rect);\n        return (rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1);\n    });\n    function processNodes(nodes, levelCoord, stackDepth) {\n        let stackForward = 0;\n        for (let node of nodes) {\n            stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n        }\n        return stackForward;\n    }\n    processNodes(topLevelNodes, 0, 0);\n    return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n}\n// TODO: move to general util\nfunction cacheable(keyFunc, workFunc) {\n    const cache = {};\n    return (...args) => {\n        let key = keyFunc(...args);\n        return (key in cache)\n            ? cache[key]\n            : (cache[key] = workFunc(...args));\n    };\n}\n\nfunction computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {\n    let vcoords = [];\n    if (slatCoords) {\n        for (let i = 0; i < segs.length; i += 1) {\n            let seg = segs[i];\n            let spanStart = slatCoords.computeDateTop(seg.start, colDate);\n            let spanEnd = Math.max(spanStart + (eventMinHeight || 0), // :(\n            slatCoords.computeDateTop(seg.end, colDate));\n            vcoords.push({\n                start: Math.round(spanStart),\n                end: Math.round(spanEnd), //\n            });\n        }\n    }\n    return vcoords;\n}\nfunction computeFgSegPlacements(segs, segVCoords, // might not have for every seg\neventOrderStrict, eventMaxStack) {\n    let segInputs = [];\n    let dumbSegs = []; // segs without coords\n    for (let i = 0; i < segs.length; i += 1) {\n        let vcoords = segVCoords[i];\n        if (vcoords) {\n            segInputs.push({\n                index: i,\n                thickness: 1,\n                span: vcoords,\n            });\n        }\n        else {\n            dumbSegs.push(segs[i]);\n        }\n    }\n    let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);\n    let segPlacements = [];\n    for (let segRect of segRects) {\n        segPlacements.push({\n            seg: segs[segRect.index],\n            rect: segRect,\n        });\n    }\n    for (let dumbSeg of dumbSegs) {\n        segPlacements.push({ seg: dumbSeg, rect: null });\n    }\n    return { segPlacements, hiddenGroups };\n}\n\nconst DEFAULT_TIME_FORMAT = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.x)({\n    hour: 'numeric',\n    minute: '2-digit',\n    meridiem: false,\n});\nclass TimeColEvent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    render() {\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cg, Object.assign({}, this.props, { elClasses: [\n                'fc-timegrid-event',\n                'fc-v-event',\n                this.props.isShort && 'fc-timegrid-event-short',\n            ], defaultTimeFormat: DEFAULT_TIME_FORMAT })));\n    }\n}\n\nclass TimeCol extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor() {\n        super(...arguments);\n        this.sortEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bP);\n    }\n    // TODO: memoize event-placement?\n    render() {\n        let { props, context } = this;\n        let { options } = context;\n        let isSelectMirror = options.selectMirror;\n        let mirrorSegs = // yuck\n         (props.eventDrag && props.eventDrag.segs) ||\n            (props.eventResize && props.eventResize.segs) ||\n            (isSelectMirror && props.dateSelectionSegs) ||\n            [];\n        let interactionAffectedInstances = // TODO: messy way to compute this\n         (props.eventDrag && props.eventDrag.affectedInstances) ||\n            (props.eventResize && props.eventResize.affectedInstances) ||\n            {};\n        let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ci, { elTag: \"td\", elRef: props.elRef, elClasses: [\n                'fc-timegrid-col',\n                ...(props.extraClassNames || []),\n            ], elAttrs: Object.assign({ role: 'gridcell' }, props.extraDataAttrs), date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraRenderProps: props.extraRenderProps }, (InnerContent) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-col-frame\" },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-col-bg\" },\n                this.renderFillSegs(props.businessHourSegs, 'non-business'),\n                this.renderFillSegs(props.bgEventSegs, 'bg-event'),\n                this.renderFillSegs(props.dateSelectionSegs, 'highlight')),\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-col-events\" }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)),\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-col-events\" }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), 'mirror')),\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-now-indicator-container\" }, this.renderNowIndicator(props.nowIndicatorSegs)),\n            (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cj)(options) && ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(InnerContent, { elTag: \"div\", elClasses: ['fc-timegrid-col-misc'] }))))));\n    }\n    renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n        let { props } = this;\n        if (props.forPrint) {\n            return renderPlainFgSegs(sortedFgSegs, props);\n        }\n        return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);\n    }\n    renderPositionedFgSegs(segs, // if not mirror, needs to be sorted\n    segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n        let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;\n        let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;\n        let isMirror = isDragging || isResizing || isDateSelecting;\n        let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n        let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null,\n            this.renderHiddenGroups(hiddenGroups, segs),\n            segPlacements.map((segPlacement) => {\n                let { seg, rect } = segPlacement;\n                let instanceId = seg.eventRange.instance.instanceId;\n                let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n                let vStyle = computeSegVStyle(rect && rect.span);\n                let hStyle = (!isMirror && rect) ? this.computeSegHStyle(rect) : { left: 0, right: 0 };\n                let isInset = Boolean(rect) && rect.stackForward > 0;\n                let isShort = Boolean(rect) && (rect.span.end - rect.span.start) < eventShortHeight; // look at other places for this problem\n                return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: 'fc-timegrid-event-harness' +\n                        (isInset ? ' fc-timegrid-event-harness-inset' : ''), key: forcedKey || instanceId, style: Object.assign(Object.assign({ visibility: isVisible ? '' : 'hidden' }, vStyle), hStyle) },\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColEvent, Object.assign({ seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === eventSelection, isShort: isShort }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, todayRange, nowDate)))));\n            })));\n    }\n    // will already have eventMinHeight applied because segInputs already had it\n    renderHiddenGroups(hiddenGroups, segs) {\n        let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, hiddenGroups.map((hiddenGroup) => {\n            let positionCss = computeSegVStyle(hiddenGroup.span);\n            let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n            return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColMoreLink, { key: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bu)((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cp)(hiddenSegs)), hiddenSegs: hiddenSegs, top: positionCss.top, bottom: positionCss.bottom, extraDateSpan: extraDateSpan, dateProfile: dateProfile, todayRange: todayRange, nowDate: nowDate, eventSelection: eventSelection, eventDrag: eventDrag, eventResize: eventResize }));\n        })));\n    }\n    renderFillSegs(segs, fillType) {\n        let { props, context } = this;\n        let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n        let children = segVCoords.map((vcoords, i) => {\n            let seg = segs[i];\n            return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { key: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bR)(seg.eventRange), className: \"fc-timegrid-bg-harness\", style: computeSegVStyle(vcoords) }, fillType === 'bg-event' ?\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cm, Object.assign({ seg: seg }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, props.todayRange, props.nowDate))) :\n                (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cl)(fillType)));\n        });\n        return (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children);\n    }\n    renderNowIndicator(segs) {\n        let { slatCoords, date } = this.props;\n        if (!slatCoords) {\n            return null;\n        }\n        return segs.map((seg, i) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ch\n        // key doesn't matter. will only ever be one\n        , { \n            // key doesn't matter. will only ever be one\n            key: i, elClasses: ['fc-timegrid-now-indicator-line'], elStyle: {\n                top: slatCoords.computeDateTop(seg.start, date),\n            }, isAxis: false, date: date })));\n    }\n    computeSegHStyle(segHCoords) {\n        let { isRtl, options } = this.context;\n        let shouldOverlap = options.slotEventOverlap;\n        let nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n        let farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n        let left; // amount of space from left edge, a fraction of the total width\n        let right; // amount of space from right edge, a fraction of the total width\n        if (shouldOverlap) {\n            // double the width, but don't go beyond the maximum forward coordinate (1.0)\n            farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n        }\n        if (isRtl) {\n            left = 1 - farCoord;\n            right = nearCoord;\n        }\n        else {\n            left = nearCoord;\n            right = 1 - farCoord;\n        }\n        let props = {\n            zIndex: segHCoords.stackDepth + 1,\n            left: left * 100 + '%',\n            right: right * 100 + '%',\n        };\n        if (shouldOverlap && !segHCoords.stackForward) {\n            // add padding to the edge so that forward stacked events don't cover the resizer's icon\n            props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n        }\n        return props;\n    }\n}\nfunction renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {\n    let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) ||\n        (eventResize ? eventResize.affectedInstances : null) ||\n        {};\n    return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, sortedFgSegs.map((seg) => {\n        let instanceId = seg.eventRange.instance.instanceId;\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { key: instanceId, style: { visibility: hiddenInstances[instanceId] ? 'hidden' : '' } },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColEvent, Object.assign({ seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === eventSelection, isShort: false }, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bQ)(seg, todayRange, nowDate)))));\n    })));\n}\nfunction computeSegVStyle(segVCoords) {\n    if (!segVCoords) {\n        return { top: '', bottom: '' };\n    }\n    return {\n        top: segVCoords.start,\n        bottom: -segVCoords.end,\n    };\n}\nfunction compileSegsFromEntries(segEntries, allSegs) {\n    return segEntries.map((segEntry) => allSegs[segEntry.index]);\n}\n\nclass TimeColsContent extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.B {\n    constructor() {\n        super(...arguments);\n        this.splitFgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitBgEventSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitBusinessHourSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitNowIndicatorSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitDateSelectionSegs = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitSegsByCol);\n        this.splitEventDrag = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByCol);\n        this.splitEventResize = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(splitInteractionByCol);\n        this.rootElRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        this.cellElRefs = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.cd();\n    }\n    render() {\n        let { props, context } = this;\n        let nowIndicatorTop = context.options.nowIndicator &&\n            props.slatCoords &&\n            props.slatCoords.safeComputeTop(props.nowDate); // might return void\n        let colCnt = props.cells.length;\n        let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n        let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n        let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n        let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n        let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n        let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n        let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-cols\", ref: this.rootElRef },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", { role: \"presentation\", style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth,\n                } },\n                props.tableColGroupNode,\n                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", { role: \"presentation\" },\n                    (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", { role: \"row\" },\n                        props.axis && ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", { \"aria-hidden\": true, className: \"fc-timegrid-col fc-timegrid-axis\" },\n                            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-col-frame\" },\n                                (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-now-indicator-container\" }, typeof nowIndicatorTop === 'number' && ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ch, { elClasses: ['fc-timegrid-now-indicator-arrow'], elStyle: { top: nowIndicatorTop }, isAxis: true, date: props.nowDate })))))),\n                        props.cells.map((cell, i) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeCol, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, fgEventSegs: fgEventSegsByRow[i], bgEventSegs: bgEventSegsByRow[i], businessHourSegs: businessHourSegsByRow[i], nowIndicatorSegs: nowIndicatorSegsByRow[i], dateSelectionSegs: dateSelectionSegsByRow[i], eventDrag: eventDragByRow[i], eventResize: eventResizeByRow[i], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint }))))))));\n    }\n    componentDidMount() {\n        this.updateCoords();\n    }\n    componentDidUpdate() {\n        this.updateCoords();\n    }\n    updateCoords() {\n        let { props } = this;\n        if (props.onColCoords &&\n            props.clientWidth !== null // means sizing has stabilized\n        ) {\n            props.onColCoords(new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.b8(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, // horizontal\n            false));\n        }\n    }\n}\nfunction collectCellEls(elMap, cells) {\n    return cells.map((cell) => elMap[cell.key]);\n}\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\nclass TimeCols extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc {\n    constructor() {\n        super(...arguments);\n        this.processSlotOptions = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(processSlotOptions);\n        this.state = {\n            slatCoords: null,\n        };\n        this.handleRootEl = (el) => {\n            if (el) {\n                this.context.registerInteractiveComponent(this, {\n                    el,\n                    isHitComboAllowed: this.props.isHitComboAllowed,\n                });\n            }\n            else {\n                this.context.unregisterInteractiveComponent(this);\n            }\n        };\n        this.handleScrollRequest = (request) => {\n            let { onScrollTopRequest } = this.props;\n            let { slatCoords } = this.state;\n            if (onScrollTopRequest && slatCoords) {\n                if (request.time) {\n                    let top = slatCoords.computeTimeTop(request.time);\n                    top = Math.ceil(top); // zoom can give weird floating-point values. rather scroll a little bit further\n                    if (top) {\n                        top += 1; // to overcome top border that slots beyond the first have. looks better\n                    }\n                    onScrollTopRequest(top);\n                }\n                return true;\n            }\n            return false;\n        };\n        this.handleColCoords = (colCoords) => {\n            this.colCoords = colCoords;\n        };\n        this.handleSlatCoords = (slatCoords) => {\n            this.setState({ slatCoords });\n            if (this.props.onSlatCoords) {\n                this.props.onSlatCoords(slatCoords);\n            }\n        };\n    }\n    render() {\n        let { props, state } = this;\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", { className: \"fc-timegrid-body\", ref: this.handleRootEl, style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth,\n            } },\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : '', tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */, onCoords: this.handleSlatCoords }),\n            (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })));\n    }\n    componentDidMount() {\n        this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n    }\n    componentDidUpdate(prevProps) {\n        this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n    }\n    componentWillUnmount() {\n        this.scrollResponder.detach();\n    }\n    queryHit(positionLeft, positionTop) {\n        let { dateEnv, options } = this.context;\n        let { colCoords } = this;\n        let { dateProfile } = this.props;\n        let { slatCoords } = this.state;\n        let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);\n        let colIndex = colCoords.leftToIndex(positionLeft);\n        let slatIndex = slatCoords.positions.topToIndex(positionTop);\n        if (colIndex != null && slatIndex != null) {\n            let cell = this.props.cells[colIndex];\n            let slatTop = slatCoords.positions.tops[slatIndex];\n            let slatHeight = slatCoords.positions.getHeight(slatIndex);\n            let partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n            let localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n            let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n            let dayDate = this.props.cells[colIndex].date;\n            let time = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bn)(dateProfile.slotMinTime, (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bm)(snapDuration, snapIndex));\n            let start = dateEnv.add(dayDate, time);\n            let end = dateEnv.add(start, snapDuration);\n            return {\n                dateProfile,\n                dateSpan: Object.assign({ range: { start, end }, allDay: false }, cell.extraDateSpan),\n                dayEl: colCoords.els[colIndex],\n                rect: {\n                    left: colCoords.lefts[colIndex],\n                    right: colCoords.rights[colIndex],\n                    top: slatTop,\n                    bottom: slatTop + slatHeight,\n                },\n                layer: 0,\n            };\n        }\n        return null;\n    }\n}\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n    let snapDuration = snapDurationOverride || slotDuration;\n    let snapsPerSlot = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.br)(slotDuration, snapDuration);\n    if (snapsPerSlot === null) {\n        snapDuration = slotDuration;\n        snapsPerSlot = 1;\n        // TODO: say warning?\n    }\n    return { snapDuration, snapsPerSlot };\n}\n\nclass DayTimeColsSlicer extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bU {\n    sliceRange(range, dayRanges) {\n        let segs = [];\n        for (let col = 0; col < dayRanges.length; col += 1) {\n            let segRange = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.o)(range, dayRanges[col]);\n            if (segRange) {\n                segs.push({\n                    start: segRange.start,\n                    end: segRange.end,\n                    isStart: segRange.start.valueOf() === range.start.valueOf(),\n                    isEnd: segRange.end.valueOf() === range.end.valueOf(),\n                    col,\n                });\n            }\n        }\n        return segs;\n    }\n}\n\nclass DayTimeCols extends _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bc {\n    constructor() {\n        super(...arguments);\n        this.buildDayRanges = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildDayRanges);\n        this.slicer = new DayTimeColsSlicer();\n        this.timeColsRef = (0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    }\n    render() {\n        let { props, context } = this;\n        let { dateProfile, dayTableModel } = props;\n        let { nowIndicator, nextDayThreshold } = context.options;\n        let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n        // give it the first row of cells\n        // TODO: would move this further down hierarchy, but sliceNowDate needs it\n        return ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.a6, { unit: nowIndicator ? 'minute' : 'day' }, (nowDate, todayRange) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TimeCols, Object.assign({ ref: this.timeColsRef }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile: dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate: nowDate, nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges), todayRange: todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords })))));\n    }\n}\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n    let ranges = [];\n    for (let date of dayTableModel.headerDates) {\n        ranges.push({\n            start: dateEnv.add(date, dateProfile.slotMinTime),\n            end: dateEnv.add(date, dateProfile.slotMaxTime),\n        });\n    }\n    return ranges;\n}\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nconst STOCK_SUB_DURATIONS = [\n    { hours: 1 },\n    { minutes: 30 },\n    { minutes: 15 },\n    { seconds: 30 },\n    { seconds: 15 },\n];\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n    let dayStart = new Date(0);\n    let slatTime = slotMinTime;\n    let slatIterator = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(0);\n    let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n    let metas = [];\n    while ((0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bq)(slatTime) < (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bq)(slotMaxTime)) {\n        let date = dateEnv.add(dayStart, slatTime);\n        let isLabeled = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.br)(slatIterator, labelInterval) !== null;\n        metas.push({\n            date,\n            time: slatTime,\n            key: date.toISOString(),\n            isoTimeStr: (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bs)(date),\n            isLabeled,\n        });\n        slatTime = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bn)(slatTime, slotDuration);\n        slatIterator = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bn)(slatIterator, slotDuration);\n    }\n    return metas;\n}\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n    let i;\n    let labelInterval;\n    let slotsPerLabel;\n    // find the smallest stock label interval that results in more than one slots-per-label\n    for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n        labelInterval = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.d)(STOCK_SUB_DURATIONS[i]);\n        slotsPerLabel = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.br)(labelInterval, slotDuration);\n        if (slotsPerLabel !== null && slotsPerLabel > 1) {\n            return labelInterval;\n        }\n    }\n    return slotDuration; // fall back\n}\n\nclass DayTimeColsView extends TimeColsView {\n    constructor() {\n        super(...arguments);\n        this.buildTimeColsModel = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildTimeColsModel);\n        this.buildSlatMetas = (0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.z)(buildSlatMetas);\n    }\n    render() {\n        let { options, dateEnv, dateProfileGenerator } = this.context;\n        let { props } = this;\n        let { dateProfile } = props;\n        let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n        let splitProps = this.allDaySplitter.splitProps(props);\n        let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n        let { dayMinWidth } = options;\n        let hasAttachedAxis = !dayMinWidth;\n        let hasDetachedAxis = dayMinWidth;\n        let headerContent = options.dayHeaders && ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bI, { dates: dayTableModel.headerDates, dateProfile: dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null }));\n        let allDayContent = (options.allDaySlot !== false) && ((contentArg) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_daygrid_internal_js__WEBPACK_IMPORTED_MODULE_2__.DayTable, Object.assign({}, splitProps.allDay, { dateProfile: dateProfile, dayTableModel: dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, this.getAllDayMaxEventProps()))));\n        let timeGridContent = (contentArg) => ((0,_fullcalendar_core_preact_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTimeCols, Object.assign({}, splitProps.timed, { dayTableModel: dayTableModel, dateProfile: dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas: slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: this.handleScrollTopRequest })));\n        return hasDetachedAxis\n            ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords)\n            : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n    }\n}\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n    let daySeries = new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bM(dateProfile.renderRange, dateProfileGenerator);\n    return new _fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.bT(daySeries, false);\n}\n\nvar css_248z = \".fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:\\\"\\\\00a0\\\"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:\\\"\\\\00a0-\\\\00a0\\\"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-arrow,.fc .fc-timegrid-now-indicator-line{pointer-events:none}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}\";\n(0,_fullcalendar_core_internal_js__WEBPACK_IMPORTED_MODULE_0__.ct)(css_248z);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGZ1bGxjYWxlbmRhcit0aW1lZ3JpZEA2LjEuMThfQGZ1bGxjYWxlbmRhcitjb3JlQDYuMS4xOC9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci90aW1lZ3JpZC9pbnRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMDFCO0FBQ3h3QjtBQUNyQjs7QUFFN0QsNkJBQTZCLDhEQUFRO0FBQ3JDO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsaUVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyRUFBYSxDQUFDLDZEQUFlO0FBQ3pDO0FBQ0Esb0JBQW9CLDJFQUFhLFNBQVMsZ0VBQWdFO0FBQzFHO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBLHFEQUFxRCxpRUFBZTtBQUNwRSxnQkFBZ0IsaUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkVBQWEsQ0FBQyw2REFBZ0IsSUFBSTtBQUNsRDtBQUNBLGFBQWEsaVJBQWlSLHFCQUFxQiwyRUFBYSxVQUFVLHNFQUFzRTtBQUNoWixZQUFZLDJFQUFhLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsNkRBQWE7QUFDeEM7QUFDQSx1REFBdUQsMkVBQWEsU0FBUyxtQkFBbUI7QUFDaEcsWUFBWSwyRUFBYSxtQ0FBbUM7QUFDNUQ7QUFDQTs7QUFFQSxnQ0FBZ0MsaUVBQWUsR0FBRyxlQUFlO0FBQ2pFO0FBQ0Es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QkFBd0IsVUFBVSx5Q0FBeUMsVUFBVSxxQ0FBcUMsVUFBVSxzQ0FBc0MsVUFBVSw0QkFBNEIsT0FBTyxrQkFBa0IsUUFBUSw0QkFBNEIsVUFBVSx5Q0FBeUMsU0FBUyxnQkFBZ0IsMENBQTBDLG9CQUFvQiwwQ0FBMEMsb0JBQW9CLDJCQUEyQixrQkFBa0IsOENBQThDLFNBQVMsT0FBTyxrQkFBa0IsUUFBUSxNQUFNLDhHQUE4Ryw2Q0FBNkMsMENBQTBDLGtCQUFrQixvQ0FBb0MsbUJBQW1CLGtCQUFrQixrQ0FBa0Msa0JBQWtCLGtDQUFrQyxvQ0FBb0Msa0JBQWtCLG1CQUFtQiw4Q0FBOEMsbUJBQW1CLGdCQUFnQiw4Q0FBOEMsMEJBQTBCLHlDQUF5QyxvQ0FBb0MsdUJBQXVCLHdDQUF3QyxxQ0FBcUMsZUFBZSxrQkFBa0Isa0JBQWtCLGFBQWEsNkJBQTZCLGdCQUFnQixNQUFNLHlDQUF5QyxRQUFRLHlDQUF5QyxPQUFPLHlFQUF5RSxvQkFBb0Isb0NBQW9DLDJDQUEyQyxtQkFBbUIscUJBQXFCLE9BQU8sa0JBQWtCLFFBQVEsVUFBVSxxQ0FBcUMsMkNBQTJDLG1CQUFtQixnQkFBZ0Isa0JBQWtCLFVBQVUsbURBQW1ELGdDQUFnQyw2QkFBNkIsMkJBQTJCLE9BQU8sbURBQW1ELGdDQUFnQyw2QkFBNkIsMkJBQTJCLFFBQVE7QUFDLzJLLGtFQUFZOztBQUVnSiIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LWNhbGVuZGFyLWN1cnNvci1ncHQ1Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BmdWxsY2FsZW5kYXIrdGltZWdyaWRANi4xLjE4X0BmdWxsY2FsZW5kYXIrY29yZUA2LjEuMTgvbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvdGltZWdyaWQvaW50ZXJuYWwuanM/OGM2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTcGxpdHRlciwgaGFzQmdSZW5kZXJpbmcsIGNyZWF0ZUZvcm1hdHRlciwgVmlld0NvbnRleHRUeXBlLCBDb250ZW50Q29udGFpbmVyLCBCYXNlQ29tcG9uZW50LCBEYXRlQ29tcG9uZW50LCBkaWZmRGF5cywgYnVpbGROYXZMaW5rQXR0cnMsIFdlZWtOdW1iZXJDb250YWluZXIsIGdldFN0aWNreUhlYWRlckRhdGVzLCBWaWV3Q29udGFpbmVyLCBTaW1wbGVTY3JvbGxHcmlkLCBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIsIE5vd1RpbWVyLCBOb3dJbmRpY2F0b3JDb250YWluZXIsIHJlbmRlclNjcm9sbFNoaW0sIHJhbmdlQ29udGFpbnNNYXJrZXIsIHN0YXJ0T2ZEYXksIGFzUm91Z2hNcywgY3JlYXRlRHVyYXRpb24sIFJlZk1hcCwgUG9zaXRpb25DYWNoZSwgTW9yZUxpbmtDb250YWluZXIsIFNlZ0hpZXJhcmNoeSwgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzLCBiaW5hcnlTZWFyY2gsIGdldEVudHJ5U3BhbkVuZCwgYnVpbGRFbnRyeUtleSwgU3RhbmRhcmRFdmVudCwgbWVtb2l6ZSwgc29ydEV2ZW50U2VncywgRGF5Q2VsbENvbnRhaW5lciwgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQsIGdldFNlZ01ldGEsIGJ1aWxkSXNvU3RyaW5nLCBjb21wdXRlRWFybGllc3RTZWdTdGFydCwgYnVpbGRFdmVudFJhbmdlS2V5LCBCZ0V2ZW50LCByZW5kZXJGaWxsLCBhZGREdXJhdGlvbnMsIG11bHRpcGx5RHVyYXRpb24sIHdob2xlRGl2aWRlRHVyYXRpb25zLCBTbGljZXIsIGludGVyc2VjdFJhbmdlcywgZm9ybWF0SXNvVGltZVN0cmluZywgRGF5SGVhZGVyLCBEYXlTZXJpZXNNb2RlbCwgRGF5VGFibGVNb2RlbCwgaW5qZWN0U3R5bGVzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZVJlZiwgRnJhZ21lbnQgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcbmltcG9ydCB7IERheVRhYmxlIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9kYXlncmlkL2ludGVybmFsLmpzJztcblxuY2xhc3MgQWxsRGF5U3BsaXR0ZXIgZXh0ZW5kcyBTcGxpdHRlciB7XG4gICAgZ2V0S2V5SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbERheToge30sXG4gICAgICAgICAgICB0aW1lZDoge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbikge1xuICAgICAgICBpZiAoZGF0ZVNwYW4uYWxsRGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWyd0aW1lZCddO1xuICAgIH1cbiAgICBnZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpIHtcbiAgICAgICAgaWYgKCFldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3RpbWVkJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0JnUmVuZGVyaW5nKGV2ZW50RGVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnLCAnYWxsRGF5J107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsnYWxsRGF5J107XG4gICAgfVxufVxuXG5jb25zdCBERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgb21pdFplcm9NaW51dGU6IHRydWUsXG4gICAgbWVyaWRpZW06ICdzaG9ydCcsXG59KTtcbmZ1bmN0aW9uIFRpbWVDb2xzQXhpc0NlbGwocHJvcHMpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QnLFxuICAgICAgICAnZmMtdGltZWdyaWQtc2xvdC1sYWJlbCcsXG4gICAgICAgIHByb3BzLmlzTGFiZWxlZCA/ICdmYy1zY3JvbGxncmlkLXNocmluaycgOiAnZmMtdGltZWdyaWQtc2xvdC1taW5vcicsXG4gICAgXTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAoIXByb3BzLmlzTGFiZWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBcImRhdGEtdGltZVwiOiBwcm9wcy5pc29UaW1lU3RyIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zLCB2aWV3QXBpIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgbGFiZWxGb3JtYXQgPSAvLyBUT0RPOiBmdWxseSBwcmUtcGFyc2VcbiAgICAgICAgIG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0ID09IG51bGwgPyBERUZBVUxUX1NMQVRfTEFCRUxfRk9STUFUIDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpID8gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0WzBdKSA6XG4gICAgICAgICAgICAgICAgY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0KTtcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICB0aW1lOiBwcm9wcy50aW1lLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgICAgICB2aWV3OiB2aWV3QXBpLFxuICAgICAgICAgICAgdGV4dDogZGF0ZUVudi5mb3JtYXQocHJvcHMuZGF0ZSwgbGFiZWxGb3JtYXQpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IGNsYXNzTmFtZXMsIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAnZGF0YS10aW1lJzogcHJvcHMuaXNvVGltZVN0cixcbiAgICAgICAgICAgIH0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJzbG90TGFiZWxDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFiZWxDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFiZWxDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFiZWxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuc2xvdExhYmVsV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1mcmFtZSBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZVwiIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgXSB9KSkpKSk7XG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5cbmNsYXNzIFRpbWVCb2R5QXhpcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc2xhdE1ldGFzLm1hcCgoc2xhdE1ldGEpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNsYXRNZXRhLmtleSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCBPYmplY3QuYXNzaWduKHt9LCBzbGF0TWV0YSkpKSkpO1xuICAgIH1cbn1cblxuY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnc2hvcnQnIH0pO1xuY29uc3QgQVVUT19BTExfREFZX01BWF9FVkVOVF9ST1dTID0gNTtcbmNsYXNzIFRpbWVDb2xzVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFsbERheVNwbGl0dGVyID0gbmV3IEFsbERheVNwbGl0dGVyKCk7IC8vIGZvciB1c2UgYnkgc3ViY2xhc3Nlc1xuICAgICAgICB0aGlzLmhlYWRlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXJFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0ID0gKHNjcm9sbFRvcCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSB0aGlzLnNjcm9sbGVyRWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxlckVsKSB7IC8vIFRPRE86IG5vdCBzdXJlIGhvdyB0aGlzIGNvdWxkIGV2ZXIgYmUgbnVsbC4gd2VpcmRuZXNzIHdpdGggdGhlIHJlZHVjZXJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyogSGVhZGVyIFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIHRoaXMucmVuZGVySGVhZEF4aXMgPSAocm93S2V5LCBmcmFtZUhlaWdodCA9ICcnKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlO1xuICAgICAgICAgICAgbGV0IGRheUNudCA9IGRpZmZEYXlzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgICAgICAgICAgLy8gb25seSBkbyBpbiBkYXkgdmlld3MgKHRvIGF2b2lkIGRvaW5nIGluIHdlZWsgdmlld3MgdGhhdCBkb250IG5lZWQgaXQpXG4gICAgICAgICAgICBsZXQgbmF2TGlua0F0dHJzID0gKGRheUNudCA9PT0gMSlcbiAgICAgICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgcmFuZ2Uuc3RhcnQsICd3ZWVrJylcbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMud2Vla051bWJlcnMgJiYgcm93S2V5ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcbiAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgZGF0ZTogcmFuZ2Uuc3RhcnQsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcy1mcmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkJyxcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IG5hdkxpbmtBdHRycyB9KSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXNcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1mcmFtZVwiLCBzdHlsZTogeyBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyogVGFibGUgQ29tcG9uZW50IFJlbmRlciBNZXRob2RzXG4gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgICAgIC8vIG9ubHkgYSBvbmUtd2F5IGhlaWdodCBzeW5jLiB3ZSBkb24ndCBzZW5kIHRoZSBheGlzIGlubmVyLWNvbnRlbnQgaGVpZ2h0IHRvIHRoZSBEYXlHcmlkLFxuICAgICAgICAvLyBidXQgRGF5R3JpZCBzdGlsbCBuZWVkcyB0byBoYXZlIGNsYXNzTmFtZXMgb24gaW5uZXIgZWxlbWVudHMgaW4gb3JkZXIgdG8gbWVhc3VyZS5cbiAgICAgICAgdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMgPSAocm93SGVpZ2h0KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogb3B0aW9ucy5hbGxEYXlUZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgcmV1c2FibGUgaG9vay4gdXNlZCBpbiBsaXN0IHZpZXcgdG9vXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcbiAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImFsbERheUNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmFsbERheUNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlckFsbERheUlubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuYWxsRGF5RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmFsbERheVdpbGxVbm1vdW50IH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgcm93SGVpZ2h0ID09IG51bGwgPyAnIGZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkJyA6ICcnLFxuICAgICAgICAgICAgICAgIF0uam9pbignICcpLCBzdHlsZTogeyBoZWlnaHQ6IHJvd0hlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwic3BhblwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc3luYy1pbm5lcicsXG4gICAgICAgICAgICAgICAgICAgIF0gfSkpKSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNsYXRDb29yZHMgPSAoc2xhdENvb3JkcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNsYXRDb29yZHMgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHJlbmRlcmluZ1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bms6IHtcbiAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYWxsRGF5Q29udGVudCB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheS1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXG4gICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aW1lQ29udGVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5yb290RWxSZWYsIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZCddLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChTaW1wbGVTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xzOiBbeyB3aWR0aDogJ3NocmluaycgfV0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbiAgICByZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVDb250ZW50LCBjb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHNsYXRDb29yZHMpIHtcbiAgICAgICAgbGV0IFNjcm9sbEdyaWQgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3Muc2Nyb2xsR3JpZEltcGw7XG4gICAgICAgIGlmICghU2Nyb2xsR3JpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTY3JvbGxHcmlkIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IChhcmcpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHRoaXMucmVuZGVySGVhZEF4aXMoJ2RheScsIGFyZy5yb3dTeW5jSGVpZ2h0c1swXSkpKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsRGF5Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAgICAgIGtleTogJ2FsbC1kYXknLFxuICAgICAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IChjb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LCB0aGlzLnJlbmRlclRhYmxlUm93QXhpcyhjb250ZW50QXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFsbERheUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheS1kaXZpZGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAgb3V0ZXJDb250ZW50OiAoIC8vIFRPRE86IHJlbmFtZSB0byBjZWxsQ29udGVudCBzbyBkb24ndCBuZWVkIHRvIGRlZmluZSA8dHI+P1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXNlY3Rpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiAyLCBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1kaXZpZGVyICcgKyBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSB9KSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzTm93SW5kaWNhdG9yID0gY29udGV4dC5vcHRpb25zLm5vd0luZGljYXRvcjtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4oY29udGV4dC5vcHRpb25zLmV4cGFuZFJvd3MpLFxuICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogKGFyZykgPT4gKFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgbm93LWluZGljYXRvciBhcnJvdyBtb3JlIERSWSB3aXRoIFRpbWVDb2xzQ29udGVudFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXMtY2h1bmtcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBzdHlsZTogeyBoZWlnaHQ6IGFyZy5leHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUJvZHlBeGlzLCB7IHNsYXRNZXRhczogc2xhdE1ldGFzIH0pKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IGlzTm93SW5kaWNhdG9yID8gJ21pbnV0ZScgOiAnZGF5JyAvKiBoYWNreSAqLyB9LCAobm93RGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm93SW5kaWNhdG9yVG9wID0gaXNOb3dJbmRpY2F0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsYXRDb29yZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3Aobm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd0luZGljYXRvckNvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvdyddLCBlbFN0eWxlOiB7IHRvcDogbm93SW5kaWNhdG9yVG9wIH0sIGlzQXhpczogdHJ1ZSwgZGF0ZTogbm93RGF0ZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlckVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWYsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9vdGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBmYWxzZSwgY29sR3JvdXBzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgd2lkdGg6ICdzaHJpbmsnLCBjb2xzOiBbeyB3aWR0aDogJ3NocmluaycgfV0gfSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xzOiBbeyBzcGFuOiBjb2xDbnQsIG1pbldpZHRoOiBkYXlNaW5XaWR0aCB9XSB9LFxuICAgICAgICAgICAgICAgIF0sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xuICAgIH1cbiAgICAvKiBEaW1lbnNpb25zXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICBnZXRBbGxEYXlNYXhFdmVudFByb3BzKCkge1xuICAgICAgICBsZXQgeyBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cyB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7IC8vIGlzIGF1dG8/XG4gICAgICAgICAgICBkYXlNYXhFdmVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1M7IC8vIG1ha2Ugc3VyZSBcImF1dG9cIiBnb2VzIHRvIGEgcmVhbCBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93cyB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckFsbERheUlubmVyKHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIHJlbmRlclByb3BzLnRleHQ7XG59XG5cbmNsYXNzIFRpbWVDb2xzU2xhdHNDb29yZHMge1xuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUsIHNsb3REdXJhdGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xuICAgICAgICB0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcbiAgICB9XG4gICAgc2FmZUNvbXB1dGVUb3AoZGF0ZSkge1xuICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlKSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheShkYXRlKTtcbiAgICAgICAgICAgIGxldCB0aW1lTXMgPSBkYXRlLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICh0aW1lTXMgPj0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSAmJlxuICAgICAgICAgICAgICAgIHRpbWVNcyA8IGFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWF4VGltZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih0aW1lTXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxuICAgIGNvbXB1dGVEYXRlVG9wKHdoZW4sIHN0YXJ0T2ZEYXlEYXRlKSB7XG4gICAgICAgIGlmICghc3RhcnRPZkRheURhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheSh3aGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih3aGVuLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKSkpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiB0aW1lIChhIER1cmF0aW9uKS5cbiAgICAvLyBUaGlzIGlzIGEgbWFrZXNoaWZ5IHdheSB0byBjb21wdXRlIHRoZSB0aW1lLXRvcC4gQXNzdW1lcyBhbGwgc2xhdE1ldGFzIGRhdGVzIGFyZSB1bmlmb3JtLlxuICAgIC8vIEV2ZW50dWFsbHkgYWxsb3cgY29tcHV0YXRpb24gd2l0aCBhcmJpcmFyeSBzbGF0IGRhdGVzLlxuICAgIGNvbXB1dGVUaW1lVG9wKGR1cmF0aW9uKSB7XG4gICAgICAgIGxldCB7IHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBsZW4gPSBwb3NpdGlvbnMuZWxzLmxlbmd0aDtcbiAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXG4gICAgICAgIGxldCBzbGF0Q292ZXJhZ2UgPSAoZHVyYXRpb24ubWlsbGlzZWNvbmRzIC0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSkgLyBhc1JvdWdoTXModGhpcy5zbG90RHVyYXRpb24pO1xuICAgICAgICBsZXQgc2xhdEluZGV4O1xuICAgICAgICBsZXQgc2xhdFJlbWFpbmRlcjtcbiAgICAgICAgLy8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cbiAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBvZiBzbGF0cyAoaW5jbHVzaXZlKVxuICAgICAgICAvLyBjb25zdHJhaW5lZCBiZWNhdXNlIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIG1pZ2h0IGJlIGN1c3RvbWl6ZWQuXG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIHNsYXRDb3ZlcmFnZSk7XG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgLy8gYW4gaW50ZWdlciBpbmRleCBvZiB0aGUgZnVydGhlc3Qgd2hvbGUgc2xhdFxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXG4gICAgICAgIHNsYXRJbmRleCA9IE1hdGguZmxvb3Ioc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5taW4oc2xhdEluZGV4LCBsZW4gLSAxKTtcbiAgICAgICAgLy8gaG93IG11Y2ggZnVydGhlciB0aHJvdWdoIHRoZSBzbGF0SW5kZXggc2xhdCAoZnJvbSAwLjAtMS4wKSBtdXN0IGJlIGNvdmVyZWQgaW4gYWRkaXRpb24uXG4gICAgICAgIC8vIGNvdWxkIGJlIDEuMCBpZiBzbGF0Q292ZXJhZ2UgaXMgY292ZXJpbmcgKmFsbCogdGhlIHNsb3RzXG4gICAgICAgIHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdICtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KSAqIHNsYXRSZW1haW5kZXI7XG4gICAgfVxufVxuXG5jbGFzcyBUaW1lQ29sc1NsYXRzQm9keSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNsYXRFbFJlZnMgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiLCBudWxsLCBwcm9wcy5zbGF0TWV0YXMubWFwKChzbGF0TWV0YSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRpbWU6IHNsYXRNZXRhLnRpbWUsXG4gICAgICAgICAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShzbGF0TWV0YS5kYXRlKSxcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyBrZXk6IHNsYXRNZXRhLmtleSwgcmVmOiBzbGF0RWxSZWZzLmNyZWF0ZVJlZihzbGF0TWV0YS5rZXkpIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuYXhpcyAmJiAoY3JlYXRlRWxlbWVudChUaW1lQ29sc0F4aXNDZWxsLCBPYmplY3QuYXNzaWduKHt9LCBzbGF0TWV0YSkpKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtc2xvdC1sYW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICFzbGF0TWV0YS5pc0xhYmVsZWQgJiYgJ2ZjLXRpbWVncmlkLXNsb3QtbWlub3InLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS10aW1lJzogc2xhdE1ldGEuaXNvVGltZVN0cixcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcInNsb3RMYW5lQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuc2xvdExhbmVDb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuc2xvdExhbmVDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFuZURpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5zbG90TGFuZVdpbGxVbm1vdW50IH0pKSk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxufVxuXG4vKlxuZm9yIHRoZSBob3Jpem9udGFsIFwic2xhdHNcIiB0aGF0IHJ1biB3aWR0aC13aXNlLiBIYXMgYSB0aW1lIGF4aXMgb24gYSBzaWRlLiBEZXBlbmRzIG9uIFJUTC5cbiovXG5jbGFzcyBUaW1lQ29sc1NsYXRzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc2xhdEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLXNsb3RzXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHByb3BzLm1pbkhlaWdodCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUgLyogcmVsaWVzIG9uIHRoZXJlIG9ubHkgYmVpbmcgYSBzaW5nbGUgPGNvbD4gZm9yIHRoZSBheGlzICovLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbHNTbGF0c0JvZHksIHsgc2xhdEVsUmVmczogdGhpcy5zbGF0RWxSZWZzLCBheGlzOiBwcm9wcy5heGlzLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcyB9KSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ29vcmRzKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNpemluZygpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5vbkNvb3JkcyAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gbWVhbnMgc2l6aW5nIGhhcyBzdGFiaWxpemVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgbGV0IHJvb3RFbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAocm9vdEVsLm9mZnNldEhlaWdodCkgeyAvLyBub3QgaGlkZGVuIGJ5IGNzc1xuICAgICAgICAgICAgICAgIHByb3BzLm9uQ29vcmRzKG5ldyBUaW1lQ29sc1NsYXRzQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RTbGF0RWxzKHRoaXMuc2xhdEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5zbGF0TWV0YXMpLCBmYWxzZSwgdHJ1ZSksIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUsIGNvbnRleHQub3B0aW9ucy5zbG90RHVyYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RTbGF0RWxzKGVsTWFwLCBzbGF0TWV0YXMpIHtcbiAgICByZXR1cm4gc2xhdE1ldGFzLm1hcCgoc2xhdE1ldGEpID0+IGVsTWFwW3NsYXRNZXRhLmtleV0pO1xufVxuXG5mdW5jdGlvbiBzcGxpdFNlZ3NCeUNvbChzZWdzLCBjb2xDbnQpIHtcbiAgICBsZXQgc2Vnc0J5Q29sID0gW107XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgIHNlZ3NCeUNvbC5wdXNoKFtdKTtcbiAgICB9XG4gICAgaWYgKHNlZ3MpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNlZ3NCeUNvbFtzZWdzW2ldLmNvbF0ucHVzaChzZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2Vnc0J5Q29sO1xufVxuZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKHVpLCBjb2xDbnQpIHtcbiAgICBsZXQgYnlSb3cgPSBbXTtcbiAgICBpZiAoIXVpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgc2VnczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNlZyBvZiB1aS5zZWdzKSB7XG4gICAgICAgICAgICBieVJvd1tzZWcuY29sXS5zZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5cbmNsYXNzIFRpbWVDb2xNb3JlTGluayBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChNb3JlTGlua0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rJ10sIGVsU3R5bGU6IHtcbiAgICAgICAgICAgICAgICB0b3A6IHByb3BzLnRvcCxcbiAgICAgICAgICAgICAgICBib3R0b206IHByb3BzLmJvdHRvbSxcbiAgICAgICAgICAgIH0sIGFsbERheURhdGU6IG51bGwsIG1vcmVDbnQ6IHByb3BzLmhpZGRlblNlZ3MubGVuZ3RoLCBhbGxTZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHBvcG92ZXJDb250ZW50OiAoKSA9PiByZW5kZXJQbGFpbkZnU2Vncyhwcm9wcy5oaWRkZW5TZWdzLCBwcm9wcyksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlck1vcmVMaW5rSW5uZXIsIGZvcmNlVGltZWQ6IHRydWUgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rLWlubmVyJywgJ2ZjLXN0aWNreSddIH0pKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuc2hvcnRUZXh0O1xufVxuXG4vLyBzZWdJbnB1dHMgYXNzdW1lZCBzb3J0ZWRcbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb25pbmcoc2VnSW5wdXRzLCBzdHJpY3RPcmRlciwgbWF4U3RhY2tDbnQpIHtcbiAgICBsZXQgaGllcmFyY2h5ID0gbmV3IFNlZ0hpZXJhcmNoeSgpO1xuICAgIGlmIChzdHJpY3RPcmRlciAhPSBudWxsKSB7XG4gICAgICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xuICAgIH1cbiAgICBpZiAobWF4U3RhY2tDbnQgIT0gbnVsbCkge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBtYXhTdGFja0NudDtcbiAgICB9XG4gICAgbGV0IGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgIGxldCBoaWRkZW5Hcm91cHMgPSBncm91cEludGVyc2VjdGluZ0VudHJpZXMoaGlkZGVuRW50cmllcyk7XG4gICAgbGV0IHdlYiA9IGJ1aWxkV2ViKGhpZXJhcmNoeSk7XG4gICAgd2ViID0gc3RyZXRjaFdlYih3ZWIsIDEpOyAvLyBhbGwgbGV2ZWxDb29yZHMvdGhpY2tuZXNzIHdpbGwgaGF2ZSAwLjAtMS4wXG4gICAgbGV0IHNlZ1JlY3RzID0gd2ViVG9SZWN0cyh3ZWIpO1xuICAgIHJldHVybiB7IHNlZ1JlY3RzLCBoaWRkZW5Hcm91cHMgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkV2ViKGhpZXJhcmNoeSkge1xuICAgIGNvbnN0IHsgZW50cmllc0J5TGV2ZWwgfSA9IGhpZXJhcmNoeTtcbiAgICBjb25zdCBidWlsZE5vZGUgPSBjYWNoZWFibGUoKGxldmVsLCBsYXRlcmFsKSA9PiBsZXZlbCArICc6JyArIGxhdGVyYWwsIChsZXZlbCwgbGF0ZXJhbCkgPT4ge1xuICAgICAgICBsZXQgc2libGluZ1JhbmdlID0gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBsZXZlbCwgbGF0ZXJhbCk7XG4gICAgICAgIGxldCBuZXh0TGV2ZWxSZXMgPSBidWlsZE5vZGVzKHNpYmxpbmdSYW5nZSwgYnVpbGROb2RlKTtcbiAgICAgICAgbGV0IGVudHJ5ID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdW2xhdGVyYWxdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgbmV4dExldmVsTm9kZXM6IG5leHRMZXZlbFJlc1swXSB9KSxcbiAgICAgICAgICAgIGVudHJ5LnRoaWNrbmVzcyArIG5leHRMZXZlbFJlc1sxXSwgLy8gdGhlIHByZXNzdXJlIGJ1aWxkc1xuICAgICAgICBdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWlsZE5vZGVzKGVudHJpZXNCeUxldmVsLmxlbmd0aFxuICAgICAgICA/IHsgbGV2ZWw6IDAsIGxhdGVyYWxTdGFydDogMCwgbGF0ZXJhbEVuZDogZW50cmllc0J5TGV2ZWxbMF0ubGVuZ3RoIH1cbiAgICAgICAgOiBudWxsLCBidWlsZE5vZGUpWzBdO1xufVxuZnVuY3Rpb24gYnVpbGROb2RlcyhzaWJsaW5nUmFuZ2UsIGJ1aWxkTm9kZSkge1xuICAgIGlmICghc2libGluZ1JhbmdlKSB7XG4gICAgICAgIHJldHVybiBbW10sIDBdO1xuICAgIH1cbiAgICBsZXQgeyBsZXZlbCwgbGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kIH0gPSBzaWJsaW5nUmFuZ2U7XG4gICAgbGV0IGxhdGVyYWwgPSBsYXRlcmFsU3RhcnQ7XG4gICAgbGV0IHBhaXJzID0gW107XG4gICAgd2hpbGUgKGxhdGVyYWwgPCBsYXRlcmFsRW5kKSB7XG4gICAgICAgIHBhaXJzLnB1c2goYnVpbGROb2RlKGxldmVsLCBsYXRlcmFsKSk7XG4gICAgICAgIGxhdGVyYWwgKz0gMTtcbiAgICB9XG4gICAgcGFpcnMuc29ydChjbXBEZXNjUHJlc3N1cmVzKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBwYWlycy5tYXAoZXh0cmFjdE5vZGUpLFxuICAgICAgICBwYWlyc1swXVsxXSwgLy8gZmlyc3QgaXRlbSdzIHByZXNzdXJlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGNtcERlc2NQcmVzc3VyZXMoYSwgYikge1xuICAgIHJldHVybiBiWzFdIC0gYVsxXTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3ROb2RlKGEpIHtcbiAgICByZXR1cm4gYVswXTtcbn1cbmZ1bmN0aW9uIGZpbmROZXh0TGV2ZWxTZWdzKGhpZXJhcmNoeSwgc3ViamVjdExldmVsLCBzdWJqZWN0TGF0ZXJhbCkge1xuICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCB9ID0gaGllcmFyY2h5O1xuICAgIGxldCBzdWJqZWN0RW50cnkgPSBlbnRyaWVzQnlMZXZlbFtzdWJqZWN0TGV2ZWxdW3N1YmplY3RMYXRlcmFsXTtcbiAgICBsZXQgYWZ0ZXJTdWJqZWN0ID0gbGV2ZWxDb29yZHNbc3ViamVjdExldmVsXSArIHN1YmplY3RFbnRyeS50aGlja25lc3M7XG4gICAgbGV0IGxldmVsQ250ID0gbGV2ZWxDb29yZHMubGVuZ3RoO1xuICAgIGxldCBsZXZlbCA9IHN1YmplY3RMZXZlbDtcbiAgICAvLyBza2lwIHBhc3QgbGV2ZWxzIHRoYXQgYXJlIHRvbyBoaWdoIHVwXG4gICAgZm9yICg7IGxldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbbGV2ZWxdIDwgYWZ0ZXJTdWJqZWN0OyBsZXZlbCArPSAxKVxuICAgICAgICA7IC8vIGRvIG5vdGhpbmdcbiAgICBmb3IgKDsgbGV2ZWwgPCBsZXZlbENudDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICBsZXQgZW50cmllcyA9IGVudHJpZXNCeUxldmVsW2xldmVsXTtcbiAgICAgICAgbGV0IGVudHJ5O1xuICAgICAgICBsZXQgc2VhcmNoSW5kZXggPSBiaW5hcnlTZWFyY2goZW50cmllcywgc3ViamVjdEVudHJ5LnNwYW4uc3RhcnQsIGdldEVudHJ5U3BhbkVuZCk7XG4gICAgICAgIGxldCBsYXRlcmFsU3RhcnQgPSBzZWFyY2hJbmRleFswXSArIHNlYXJjaEluZGV4WzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgbGV0IGxhdGVyYWxFbmQgPSBsYXRlcmFsU3RhcnQ7XG4gICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgIChlbnRyeSA9IGVudHJpZXNbbGF0ZXJhbEVuZF0pICYmIC8vIGJ1dCBub3QgcGFzdCB0aGUgd2hvbGUgc2VnIGxpc3RcbiAgICAgICAgICAgIGVudHJ5LnNwYW4uc3RhcnQgPCBzdWJqZWN0RW50cnkuc3Bhbi5lbmQpIHtcbiAgICAgICAgICAgIGxhdGVyYWxFbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF0ZXJhbFN0YXJ0IDwgbGF0ZXJhbEVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGV2ZWwsIGxhdGVyYWxTdGFydCwgbGF0ZXJhbEVuZCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc3RyZXRjaFdlYih0b3BMZXZlbE5vZGVzLCB0b3RhbFRoaWNrbmVzcykge1xuICAgIGNvbnN0IHN0cmV0Y2hOb2RlID0gY2FjaGVhYmxlKChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSA9PiBidWlsZEVudHJ5S2V5KG5vZGUpLCAobm9kZSwgc3RhcnRDb29yZCwgcHJldlRoaWNrbmVzcykgPT4ge1xuICAgICAgICBsZXQgeyBuZXh0TGV2ZWxOb2RlcywgdGhpY2tuZXNzIH0gPSBub2RlO1xuICAgICAgICBsZXQgYWxsVGhpY2tuZXNzID0gdGhpY2tuZXNzICsgcHJldlRoaWNrbmVzcztcbiAgICAgICAgbGV0IHRoaWNrbmVzc0ZyYWN0aW9uID0gdGhpY2tuZXNzIC8gYWxsVGhpY2tuZXNzO1xuICAgICAgICBsZXQgZW5kQ29vcmQ7XG4gICAgICAgIGxldCBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAoIW5leHRMZXZlbE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kQ29vcmQgPSB0b3RhbFRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkTm9kZSBvZiBuZXh0TGV2ZWxOb2Rlcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmRDb29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIHN0YXJ0Q29vcmQsIGFsbFRoaWNrbmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZENvb3JkID0gcmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHJlc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gc3RyZXRjaE5vZGUoY2hpbGROb2RlLCBlbmRDb29yZCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1RoaWNrbmVzcyA9IChlbmRDb29yZCAtIHN0YXJ0Q29vcmQpICogdGhpY2tuZXNzRnJhY3Rpb247XG4gICAgICAgIHJldHVybiBbZW5kQ29vcmQgLSBuZXdUaGlja25lc3MsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZSksIHsgdGhpY2tuZXNzOiBuZXdUaGlja25lc3MsIG5leHRMZXZlbE5vZGVzOiBuZXdDaGlsZHJlbiB9KV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvcExldmVsTm9kZXMubWFwKChub2RlKSA9PiBzdHJldGNoTm9kZShub2RlLCAwLCAwKVsxXSk7XG59XG4vLyBub3Qgc29ydGVkIGluIGFueSBwYXJ0aWN1bGFyIG9yZGVyXG5mdW5jdGlvbiB3ZWJUb1JlY3RzKHRvcExldmVsTm9kZXMpIHtcbiAgICBsZXQgcmVjdHMgPSBbXTtcbiAgICBjb25zdCBwcm9jZXNzTm9kZSA9IGNhY2hlYWJsZSgobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgPT4gYnVpbGRFbnRyeUtleShub2RlKSwgKG5vZGUsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpID0+IHtcbiAgICAgICAgbGV0IHJlY3QgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vZGUpLCB7IGxldmVsQ29vcmQsXG4gICAgICAgICAgICBzdGFja0RlcHRoLCBzdGFja0ZvcndhcmQ6IDAgfSk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICAgIHJldHVybiAocmVjdC5zdGFja0ZvcndhcmQgPSBwcm9jZXNzTm9kZXMobm9kZS5uZXh0TGV2ZWxOb2RlcywgbGV2ZWxDb29yZCArIG5vZGUudGhpY2tuZXNzLCBzdGFja0RlcHRoICsgMSkgKyAxKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZXMobm9kZXMsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpIHtcbiAgICAgICAgbGV0IHN0YWNrRm9yd2FyZCA9IDA7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIHN0YWNrRm9yd2FyZCA9IE1hdGgubWF4KHByb2Nlc3NOb2RlKG5vZGUsIGxldmVsQ29vcmQsIHN0YWNrRGVwdGgpLCBzdGFja0ZvcndhcmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFja0ZvcndhcmQ7XG4gICAgfVxuICAgIHByb2Nlc3NOb2Rlcyh0b3BMZXZlbE5vZGVzLCAwLCAwKTtcbiAgICByZXR1cm4gcmVjdHM7IC8vIFRPRE86IHNvcnQgcmVjdHMgYnkgbGV2ZWxDb29yZCB0byBiZSBjb25zaXN0ZW50IHdpdGggdG9SZWN0cz9cbn1cbi8vIFRPRE86IG1vdmUgdG8gZ2VuZXJhbCB1dGlsXG5mdW5jdGlvbiBjYWNoZWFibGUoa2V5RnVuYywgd29ya0Z1bmMpIHtcbiAgICBjb25zdCBjYWNoZSA9IHt9O1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBsZXQga2V5ID0ga2V5RnVuYyguLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIChrZXkgaW4gY2FjaGUpXG4gICAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICAgIDogKGNhY2hlW2tleV0gPSB3b3JrRnVuYyguLi5hcmdzKSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNlZ1ZDb29yZHMoc2VncywgY29sRGF0ZSwgc2xhdENvb3JkcyA9IG51bGwsIGV2ZW50TWluSGVpZ2h0ID0gMCkge1xuICAgIGxldCB2Y29vcmRzID0gW107XG4gICAgaWYgKHNsYXRDb29yZHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIGxldCBzcGFuU3RhcnQgPSBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgY29sRGF0ZSk7XG4gICAgICAgICAgICBsZXQgc3BhbkVuZCA9IE1hdGgubWF4KHNwYW5TdGFydCArIChldmVudE1pbkhlaWdodCB8fCAwKSwgLy8gOihcbiAgICAgICAgICAgIHNsYXRDb29yZHMuY29tcHV0ZURhdGVUb3Aoc2VnLmVuZCwgY29sRGF0ZSkpO1xuICAgICAgICAgICAgdmNvb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogTWF0aC5yb3VuZChzcGFuU3RhcnQpLFxuICAgICAgICAgICAgICAgIGVuZDogTWF0aC5yb3VuZChzcGFuRW5kKSwgLy9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2Y29vcmRzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCAvLyBtaWdodCBub3QgaGF2ZSBmb3IgZXZlcnkgc2VnXG5ldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKSB7XG4gICAgbGV0IHNlZ0lucHV0cyA9IFtdO1xuICAgIGxldCBkdW1iU2VncyA9IFtdOyAvLyBzZWdzIHdpdGhvdXQgY29vcmRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCB2Y29vcmRzID0gc2VnVkNvb3Jkc1tpXTtcbiAgICAgICAgaWYgKHZjb29yZHMpIHtcbiAgICAgICAgICAgIHNlZ0lucHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IDEsXG4gICAgICAgICAgICAgICAgc3BhbjogdmNvb3JkcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVtYlNlZ3MucHVzaChzZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgeyBzZWdSZWN0cywgaGlkZGVuR3JvdXBzIH0gPSBidWlsZFBvc2l0aW9uaW5nKHNlZ0lucHV0cywgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjayk7XG4gICAgbGV0IHNlZ1BsYWNlbWVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBzZWdSZWN0IG9mIHNlZ1JlY3RzKSB7XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBzZWc6IHNlZ3Nbc2VnUmVjdC5pbmRleF0sXG4gICAgICAgICAgICByZWN0OiBzZWdSZWN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgZHVtYlNlZyBvZiBkdW1iU2Vncykge1xuICAgICAgICBzZWdQbGFjZW1lbnRzLnB1c2goeyBzZWc6IGR1bWJTZWcsIHJlY3Q6IG51bGwgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNlZ1BsYWNlbWVudHMsIGhpZGRlbkdyb3VwcyB9O1xufVxuXG5jb25zdCBERUZBVUxUX1RJTUVfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgbWVyaWRpZW06IGZhbHNlLFxufSk7XG5jbGFzcyBUaW1lQ29sRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChTdGFuZGFyZEV2ZW50LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1ldmVudCcsXG4gICAgICAgICAgICAgICAgJ2ZjLXYtZXZlbnQnLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuaXNTaG9ydCAmJiAnZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQnLFxuICAgICAgICAgICAgXSwgZGVmYXVsdFRpbWVGb3JtYXQ6IERFRkFVTFRfVElNRV9GT1JNQVQgfSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRpbWVDb2wgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zb3J0RXZlbnRTZWdzID0gbWVtb2l6ZShzb3J0RXZlbnRTZWdzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogbWVtb2l6ZSBldmVudC1wbGFjZW1lbnQ/XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IGlzU2VsZWN0TWlycm9yID0gb3B0aW9ucy5zZWxlY3RNaXJyb3I7XG4gICAgICAgIGxldCBtaXJyb3JTZWdzID0gLy8geXVja1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2VncykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzKSB8fFxuICAgICAgICAgICAgKGlzU2VsZWN0TWlycm9yICYmIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzKSB8fFxuICAgICAgICAgICAgW107XG4gICAgICAgIGxldCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xuICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgbGV0IHNvcnRlZEZnU2VncyA9IHRoaXMuc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KERheUNlbGxDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxSZWY6IHByb3BzLmVsUmVmLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtY29sJyxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnZ3JpZGNlbGwnIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQpID0+IChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1iZ1wiIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCAnbm9uLWJ1c2luZXNzJyksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgJ2JnLWV2ZW50JyksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgJ2hpZ2hsaWdodCcpKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWV2ZW50c1wiIH0sIHRoaXMucmVuZGVyRmdTZWdzKHNvcnRlZEZnU2VncywgaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcywgZmFsc2UsIGZhbHNlLCBmYWxzZSkpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZXZlbnRzXCIgfSwgdGhpcy5yZW5kZXJGZ1NlZ3MobWlycm9yU2Vncywge30sIEJvb2xlYW4ocHJvcHMuZXZlbnREcmFnKSwgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksIEJvb2xlYW4oaXNTZWxlY3RNaXJyb3IpLCAnbWlycm9yJykpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lclwiIH0sIHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKHByb3BzLm5vd0luZGljYXRvclNlZ3MpKSxcbiAgICAgICAgICAgIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpICYmIChjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLWNvbC1taXNjJ10gfSkpKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMuZm9yUHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJQbGFpbkZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJQb3NpdGlvbmVkRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KTtcbiAgICB9XG4gICAgcmVuZGVyUG9zaXRpb25lZEZnU2VncyhzZWdzLCAvLyBpZiBub3QgbWlycm9yLCBuZWVkcyB0byBiZSBzb3J0ZWRcbiAgICBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpIHtcbiAgICAgICAgbGV0IHsgZXZlbnRNYXhTdGFjaywgZXZlbnRTaG9ydEhlaWdodCwgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNaW5IZWlnaHQgfSA9IHRoaXMuY29udGV4dC5vcHRpb25zO1xuICAgICAgICBsZXQgeyBkYXRlLCBzbGF0Q29vcmRzLCBldmVudFNlbGVjdGlvbiwgdG9kYXlSYW5nZSwgbm93RGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcbiAgICAgICAgbGV0IHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBkYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCk7XG4gICAgICAgIGxldCB7IHNlZ1BsYWNlbWVudHMsIGhpZGRlbkdyb3VwcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWRkZW5Hcm91cHMoaGlkZGVuR3JvdXBzLCBzZWdzKSxcbiAgICAgICAgICAgIHNlZ1BsYWNlbWVudHMubWFwKChzZWdQbGFjZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgeyBzZWcsIHJlY3QgfSA9IHNlZ1BsYWNlbWVudDtcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgbGV0IGlzVmlzaWJsZSA9IGlzTWlycm9yIHx8IEJvb2xlYW4oIXNlZ0lzSW52aXNpYmxlW2luc3RhbmNlSWRdICYmIHJlY3QpO1xuICAgICAgICAgICAgICAgIGxldCB2U3R5bGUgPSBjb21wdXRlU2VnVlN0eWxlKHJlY3QgJiYgcmVjdC5zcGFuKTtcbiAgICAgICAgICAgICAgICBsZXQgaFN0eWxlID0gKCFpc01pcnJvciAmJiByZWN0KSA/IHRoaXMuY29tcHV0ZVNlZ0hTdHlsZShyZWN0KSA6IHsgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgICAgICAgICBsZXQgaXNJbnNldCA9IEJvb2xlYW4ocmVjdCkgJiYgcmVjdC5zdGFja0ZvcndhcmQgPiAwO1xuICAgICAgICAgICAgICAgIGxldCBpc1Nob3J0ID0gQm9vbGVhbihyZWN0KSAmJiAocmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCkgPCBldmVudFNob3J0SGVpZ2h0OyAvLyBsb29rIGF0IG90aGVyIHBsYWNlcyBmb3IgdGhpcyBwcm9ibGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGlzSW5zZXQgPyAnIGZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MtaW5zZXQnIDogJycpLCBrZXk6IGZvcmNlZEtleSB8fCBpbnN0YW5jZUlkLCBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdmlzaWJpbGl0eTogaXNWaXNpYmxlID8gJycgOiAnaGlkZGVuJyB9LCB2U3R5bGUpLCBoU3R5bGUpIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbEV2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgaXNTaG9ydDogaXNTaG9ydCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSkpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgLy8gd2lsbCBhbHJlYWR5IGhhdmUgZXZlbnRNaW5IZWlnaHQgYXBwbGllZCBiZWNhdXNlIHNlZ0lucHV0cyBhbHJlYWR5IGhhZCBpdFxuICAgIHJlbmRlckhpZGRlbkdyb3VwcyhoaWRkZW5Hcm91cHMsIHNlZ3MpIHtcbiAgICAgICAgbGV0IHsgZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcsIGV2ZW50UmVzaXplIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGhpZGRlbkdyb3Vwcy5tYXAoKGhpZGRlbkdyb3VwKSA9PiB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25Dc3MgPSBjb21wdXRlU2VnVlN0eWxlKGhpZGRlbkdyb3VwLnNwYW4pO1xuICAgICAgICAgICAgbGV0IGhpZGRlblNlZ3MgPSBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKGhpZGRlbkdyb3VwLmVudHJpZXMsIHNlZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRpbWVDb2xNb3JlTGluaywgeyBrZXk6IGJ1aWxkSXNvU3RyaW5nKGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KGhpZGRlblNlZ3MpKSwgaGlkZGVuU2VnczogaGlkZGVuU2VncywgdG9wOiBwb3NpdGlvbkNzcy50b3AsIGJvdHRvbTogcG9zaXRpb25Dc3MuYm90dG9tLCBleHRyYURhdGVTcGFuOiBleHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIG5vd0RhdGU6IG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uOiBldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBldmVudERyYWcsIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZSB9KSk7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckZpbGxTZWdzKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIHByb3BzLmRhdGUsIHByb3BzLnNsYXRDb29yZHMsIGNvbnRleHQub3B0aW9ucy5ldmVudE1pbkhlaWdodCk7IC8vIGRvbid0IGFzc3VtZSBhbGwgcG9wdWxhdGVkXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHNlZ1ZDb29yZHMubWFwKCh2Y29vcmRzLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGNvbXB1dGVTZWdWU3R5bGUodmNvb3JkcykgfSwgZmlsbFR5cGUgPT09ICdiZy1ldmVudCcgP1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQmdFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlLCBwcm9wcy5ub3dEYXRlKSkpIDpcbiAgICAgICAgICAgICAgICByZW5kZXJGaWxsKGZpbGxUeXBlKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmVuZGVyTm93SW5kaWNhdG9yKHNlZ3MpIHtcbiAgICAgICAgbGV0IHsgc2xhdENvb3JkcywgZGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKCFzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vncy5tYXAoKHNlZywgaSkgPT4gKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yQ29udGFpbmVyXG4gICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXG4gICAgICAgICwgeyBcbiAgICAgICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXG4gICAgICAgICAgICBrZXk6IGksIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWxpbmUnXSwgZWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHRvcDogc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGRhdGUpLFxuICAgICAgICAgICAgfSwgaXNBeGlzOiBmYWxzZSwgZGF0ZTogZGF0ZSB9KSkpO1xuICAgIH1cbiAgICBjb21wdXRlU2VnSFN0eWxlKHNlZ0hDb29yZHMpIHtcbiAgICAgICAgbGV0IHsgaXNSdGwsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHNob3VsZE92ZXJsYXAgPSBvcHRpb25zLnNsb3RFdmVudE92ZXJsYXA7XG4gICAgICAgIGxldCBuZWFyQ29vcmQgPSBzZWdIQ29vcmRzLmxldmVsQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG4gICAgICAgIGxldCBmYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZCArIHNlZ0hDb29yZHMudGhpY2tuZXNzOyAvLyB0aGUgcmlnaHQgc2lkZSBpZiBMVFIuIHRoZSBsZWZ0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxuICAgICAgICBsZXQgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxuICAgICAgICBsZXQgcmlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIHJpZ2h0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIGlmIChzaG91bGRPdmVybGFwKSB7XG4gICAgICAgICAgICAvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxuICAgICAgICAgICAgZmFyQ29vcmQgPSBNYXRoLm1pbigxLCBuZWFyQ29vcmQgKyAoZmFyQ29vcmQgLSBuZWFyQ29vcmQpICogMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUnRsKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMSAtIGZhckNvb3JkO1xuICAgICAgICAgICAgcmlnaHQgPSBuZWFyQ29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gbmVhckNvb3JkO1xuICAgICAgICAgICAgcmlnaHQgPSAxIC0gZmFyQ29vcmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3BzID0ge1xuICAgICAgICAgICAgekluZGV4OiBzZWdIQ29vcmRzLnN0YWNrRGVwdGggKyAxLFxuICAgICAgICAgICAgbGVmdDogbGVmdCAqIDEwMCArICclJyxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCAqIDEwMCArICclJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXAgJiYgIXNlZ0hDb29yZHMuc3RhY2tGb3J3YXJkKSB7XG4gICAgICAgICAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgZWRnZSBzbyB0aGF0IGZvcndhcmQgc3RhY2tlZCBldmVudHMgZG9uJ3QgY292ZXIgdGhlIHJlc2l6ZXIncyBpY29uXG4gICAgICAgICAgICBwcm9wc1tpc1J0bCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCB7IHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcsIGV2ZW50UmVzaXplIH0pIHtcbiAgICBsZXQgaGlkZGVuSW5zdGFuY2VzID0gKGV2ZW50RHJhZyA/IGV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgIChldmVudFJlc2l6ZSA/IGV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAge307XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzb3J0ZWRGZ1NlZ3MubWFwKChzZWcpID0+IHtcbiAgICAgICAgbGV0IGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7IHZpc2liaWxpdHk6IGhpZGRlbkluc3RhbmNlc1tpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogJycgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgaXNTaG9ydDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpKSkpKTtcbiAgICB9KSkpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1ZTdHlsZShzZWdWQ29vcmRzKSB7XG4gICAgaWYgKCFzZWdWQ29vcmRzKSB7XG4gICAgICAgIHJldHVybiB7IHRvcDogJycsIGJvdHRvbTogJycgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBzZWdWQ29vcmRzLnN0YXJ0LFxuICAgICAgICBib3R0b206IC1zZWdWQ29vcmRzLmVuZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVNlZ3NGcm9tRW50cmllcyhzZWdFbnRyaWVzLCBhbGxTZWdzKSB7XG4gICAgcmV0dXJuIHNlZ0VudHJpZXMubWFwKChzZWdFbnRyeSkgPT4gYWxsU2Vnc1tzZWdFbnRyeS5pbmRleF0pO1xufVxuXG5jbGFzcyBUaW1lQ29sc0NvbnRlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zcGxpdEZnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50UmVzaXplID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlDb2wpO1xuICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLmNlbGxFbFJlZnMgPSBuZXcgUmVmTWFwKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBub3dJbmRpY2F0b3JUb3AgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yICYmXG4gICAgICAgICAgICBwcm9wcy5zbGF0Q29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5zbGF0Q29vcmRzLnNhZmVDb21wdXRlVG9wKHByb3BzLm5vd0RhdGUpOyAvLyBtaWdodCByZXR1cm4gdm9pZFxuICAgICAgICBsZXQgY29sQ250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICBsZXQgZmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRGZ0V2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBidXNpbmVzc0hvdXJTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QnVzaW5lc3NIb3VyU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgbm93SW5kaWNhdG9yU2Vnc0J5Um93ID0gdGhpcy5zcGxpdE5vd0luZGljYXRvclNlZ3MocHJvcHMubm93SW5kaWNhdG9yU2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3cgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBldmVudERyYWdCeVJvdyA9IHRoaXMuc3BsaXRFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCBjb2xDbnQpO1xuICAgICAgICBsZXQgZXZlbnRSZXNpemVCeVJvdyA9IHRoaXMuc3BsaXRFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgY29sQ250KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbHNcIiwgcmVmOiB0aGlzLnJvb3RFbFJlZiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgcHJvcHMudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wgZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZnJhbWVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSwgdHlwZW9mIG5vd0luZGljYXRvclRvcCA9PT0gJ251bWJlcicgJiYgKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10sIGVsU3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSwgaXNBeGlzOiB0cnVlLCBkYXRlOiBwcm9wcy5ub3dEYXRlIH0pKSkpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5jZWxscy5tYXAoKGNlbGwsIGkpID0+IChjcmVhdGVFbGVtZW50KFRpbWVDb2wsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IHRoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgbm93RGF0ZTogcHJvcHMubm93RGF0ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFSZW5kZXJQcm9wczogY2VsbC5leHRyYVJlbmRlclByb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBmZ0V2ZW50U2VnczogZmdFdmVudFNlZ3NCeVJvd1tpXSwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbaV0sIGJ1c2luZXNzSG91clNlZ3M6IGJ1c2luZXNzSG91clNlZ3NCeVJvd1tpXSwgbm93SW5kaWNhdG9yU2Vnczogbm93SW5kaWNhdG9yU2Vnc0J5Um93W2ldLCBkYXRlU2VsZWN0aW9uU2VnczogZGF0ZVNlbGVjdGlvblNlZ3NCeVJvd1tpXSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tpXSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbaV0sIHNsYXRDb29yZHM6IHByb3BzLnNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSkpKSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29vcmRzKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9XG4gICAgdXBkYXRlQ29vcmRzKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLm9uQ29sQ29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBtZWFucyBzaXppbmcgaGFzIHN0YWJpbGl6ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBwcm9wcy5vbkNvbENvb3JkcyhuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbFJlZi5jdXJyZW50LCBjb2xsZWN0Q2VsbEVscyh0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcCwgcHJvcHMuY2VsbHMpLCB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgICAgICBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdENlbGxFbHMoZWxNYXAsIGNlbGxzKSB7XG4gICAgcmV0dXJuIGNlbGxzLm1hcCgoY2VsbCkgPT4gZWxNYXBbY2VsbC5rZXldKTtcbn1cblxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIG9uZSBvciBtb3JlIGNvbHVtbnMgb2YgdmVydGljYWwgdGltZSBzbG90c1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jbGFzcyBUaW1lQ29scyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnByb2Nlc3NTbG90T3B0aW9ucyA9IG1lbW9pemUocHJvY2Vzc1Nsb3RPcHRpb25zKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNsYXRDb29yZHM6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCA9IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBvblNjcm9sbFRvcFJlcXVlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBsZXQgeyBzbGF0Q29vcmRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKG9uU2Nyb2xsVG9wUmVxdWVzdCAmJiBzbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudGltZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG9wID0gc2xhdENvb3Jkcy5jb21wdXRlVGltZVRvcChyZXF1ZXN0LnRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLmNlaWwodG9wKTsgLy8gem9vbSBjYW4gZ2l2ZSB3ZWlyZCBmbG9hdGluZy1wb2ludCB2YWx1ZXMuIHJhdGhlciBzY3JvbGwgYSBsaXR0bGUgYml0IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wICs9IDE7IC8vIHRvIG92ZXJjb21lIHRvcCBib3JkZXIgdGhhdCBzbG90cyBiZXlvbmQgdGhlIGZpcnN0IGhhdmUuIGxvb2tzIGJldHRlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uU2Nyb2xsVG9wUmVxdWVzdCh0b3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDb2xDb29yZHMgPSAoY29sQ29vcmRzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbENvb3JkcyA9IGNvbENvb3JkcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTbGF0Q29vcmRzID0gKHNsYXRDb29yZHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzbGF0Q29vcmRzIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25TbGF0Q29vcmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNsYXRDb29yZHMoc2xhdENvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYm9keVwiLCByZWY6IHRoaXMuaGFuZGxlUm9vdEVsLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHByb3BzIGFyZSBpbXBvcnRhbnQgdG8gZ2l2ZSB0aGlzIHdyYXBwZXIgY29ycmVjdCBkaW1lbnNpb25zIGZvciBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpZiB3ZSBzZXQgaXQgaGVyZSwgY2FuIHdlIGF2b2lkIGdpdmluZyB0byBpbm5lciB0YWJsZXM/XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzLCB7IGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgc2xhdE1ldGFzOiBwcm9wcy5zbGF0TWV0YXMsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgbWluSGVpZ2h0OiBwcm9wcy5leHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy5heGlzID8gcHJvcHMudGFibGVDb2xHcm91cE5vZGUgOiBudWxsIC8qIGF4aXMgZGVwZW5kcyBvbiB0aGUgY29sZ3JvdXAncyBzaHJpbmtpbmcgKi8sIG9uQ29vcmRzOiB0aGlzLmhhbmRsZVNsYXRDb29yZHMgfSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzQ29udGVudCwgeyBjZWxsczogcHJvcHMuY2VsbHMsIGF4aXM6IHByb3BzLmF4aXMsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgYnVzaW5lc3NIb3VyU2VnczogcHJvcHMuYnVzaW5lc3NIb3VyU2VncywgYmdFdmVudFNlZ3M6IHByb3BzLmJnRXZlbnRTZWdzLCBmZ0V2ZW50U2VnczogcHJvcHMuZmdFdmVudFNlZ3MsIGRhdGVTZWxlY3Rpb25TZWdzOiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBub3dEYXRlOiBwcm9wcy5ub3dEYXRlLCBub3dJbmRpY2F0b3JTZWdzOiBwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgc2xhdENvb3Jkczogc3RhdGUuc2xhdENvb3Jkcywgb25Db2xDb29yZHM6IHRoaXMuaGFuZGxlQ29sQ29vcmRzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVNjcm9sbFJlc3BvbmRlcih0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyLnVwZGF0ZShwcmV2UHJvcHMuZGF0ZVByb2ZpbGUgIT09IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBjb2xDb29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBzbGF0Q29vcmRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgeyBzbmFwRHVyYXRpb24sIHNuYXBzUGVyU2xvdCB9ID0gdGhpcy5wcm9jZXNzU2xvdE9wdGlvbnModGhpcy5wcm9wcy5zbG90RHVyYXRpb24sIG9wdGlvbnMuc25hcER1cmF0aW9uKTtcbiAgICAgICAgbGV0IGNvbEluZGV4ID0gY29sQ29vcmRzLmxlZnRUb0luZGV4KHBvc2l0aW9uTGVmdCk7XG4gICAgICAgIGxldCBzbGF0SW5kZXggPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcbiAgICAgICAgaWYgKGNvbEluZGV4ICE9IG51bGwgJiYgc2xhdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjZWxsID0gdGhpcy5wcm9wcy5jZWxsc1tjb2xJbmRleF07XG4gICAgICAgICAgICBsZXQgc2xhdFRvcCA9IHNsYXRDb29yZHMucG9zaXRpb25zLnRvcHNbc2xhdEluZGV4XTtcbiAgICAgICAgICAgIGxldCBzbGF0SGVpZ2h0ID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMuZ2V0SGVpZ2h0KHNsYXRJbmRleCk7XG4gICAgICAgICAgICBsZXQgcGFydGlhbCA9IChwb3NpdGlvblRvcCAtIHNsYXRUb3ApIC8gc2xhdEhlaWdodDsgLy8gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICAgICAgbGV0IGxvY2FsU25hcEluZGV4ID0gTWF0aC5mbG9vcihwYXJ0aWFsICogc25hcHNQZXJTbG90KTsgLy8gdGhlIHNuYXAgIyByZWxhdGl2ZSB0byBzdGFydCBvZiBzbGF0XG4gICAgICAgICAgICBsZXQgc25hcEluZGV4ID0gc2xhdEluZGV4ICogc25hcHNQZXJTbG90ICsgbG9jYWxTbmFwSW5kZXg7XG4gICAgICAgICAgICBsZXQgZGF5RGF0ZSA9IHRoaXMucHJvcHMuY2VsbHNbY29sSW5kZXhdLmRhdGU7XG4gICAgICAgICAgICBsZXQgdGltZSA9IGFkZER1cmF0aW9ucyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgbXVsdGlwbHlEdXJhdGlvbihzbmFwRHVyYXRpb24sIHNuYXBJbmRleCkpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gZGF0ZUVudi5hZGQoZGF5RGF0ZSwgdGltZSk7XG4gICAgICAgICAgICBsZXQgZW5kID0gZGF0ZUVudi5hZGQoc3RhcnQsIHNuYXBEdXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBPYmplY3QuYXNzaWduKHsgcmFuZ2U6IHsgc3RhcnQsIGVuZCB9LCBhbGxEYXk6IGZhbHNlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IGNvbENvb3Jkcy5lbHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sQ29vcmRzLmxlZnRzW2NvbEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbENvb3Jkcy5yaWdodHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHNsYXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc2xhdFRvcCArIHNsYXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPcHRpb25zKHNsb3REdXJhdGlvbiwgc25hcER1cmF0aW9uT3ZlcnJpZGUpIHtcbiAgICBsZXQgc25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uT3ZlcnJpZGUgfHwgc2xvdER1cmF0aW9uO1xuICAgIGxldCBzbmFwc1BlclNsb3QgPSB3aG9sZURpdmlkZUR1cmF0aW9ucyhzbG90RHVyYXRpb24sIHNuYXBEdXJhdGlvbik7XG4gICAgaWYgKHNuYXBzUGVyU2xvdCA9PT0gbnVsbCkge1xuICAgICAgICBzbmFwRHVyYXRpb24gPSBzbG90RHVyYXRpb247XG4gICAgICAgIHNuYXBzUGVyU2xvdCA9IDE7XG4gICAgICAgIC8vIFRPRE86IHNheSB3YXJuaW5nP1xuICAgIH1cbiAgICByZXR1cm4geyBzbmFwRHVyYXRpb24sIHNuYXBzUGVyU2xvdCB9O1xufVxuXG5jbGFzcyBEYXlUaW1lQ29sc1NsaWNlciBleHRlbmRzIFNsaWNlciB7XG4gICAgc2xpY2VSYW5nZShyYW5nZSwgZGF5UmFuZ2VzKSB7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGRheVJhbmdlcy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBsZXQgc2VnUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlc1tjb2xdKTtcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWdSYW5nZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWdSYW5nZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gcmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cblxuY2xhc3MgRGF5VGltZUNvbHMgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idWlsZERheVJhbmdlcyA9IG1lbW9pemUoYnVpbGREYXlSYW5nZXMpO1xuICAgICAgICB0aGlzLnNsaWNlciA9IG5ldyBEYXlUaW1lQ29sc1NsaWNlcigpO1xuICAgICAgICB0aGlzLnRpbWVDb2xzUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgbm93SW5kaWNhdG9yLCBuZXh0RGF5VGhyZXNob2xkIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCBkYXlSYW5nZXMgPSB0aGlzLmJ1aWxkRGF5UmFuZ2VzKGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYpO1xuICAgICAgICAvLyBnaXZlIGl0IHRoZSBmaXJzdCByb3cgb2YgY2VsbHNcbiAgICAgICAgLy8gVE9ETzogd291bGQgbW92ZSB0aGlzIGZ1cnRoZXIgZG93biBoaWVyYXJjaHksIGJ1dCBzbGljZU5vd0RhdGUgbmVlZHMgaXRcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IG5vd0luZGljYXRvciA/ICdtaW51dGUnIDogJ2RheScgfSwgKG5vd0RhdGUsIHRvZGF5UmFuZ2UpID0+IChjcmVhdGVFbGVtZW50KFRpbWVDb2xzLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRpbWVDb2xzUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBudWxsLCBjb250ZXh0LCBkYXlSYW5nZXMpLCB7IGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcywgc2xvdER1cmF0aW9uOiBwcm9wcy5zbG90RHVyYXRpb24sIGNlbGxzOiBkYXlUYWJsZU1vZGVsLmNlbGxzWzBdLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIG5vd0RhdGU6IG5vd0RhdGUsIG5vd0luZGljYXRvclNlZ3M6IG5vd0luZGljYXRvciAmJiB0aGlzLnNsaWNlci5zbGljZU5vd0RhdGUobm93RGF0ZSwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIGRheVJhbmdlcyksIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIG9uU2Nyb2xsVG9wUmVxdWVzdDogcHJvcHMub25TY3JvbGxUb3BSZXF1ZXN0LCBvblNsYXRDb29yZHM6IHByb3BzLm9uU2xhdENvb3JkcyB9KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGRhdGVFbnYpIHtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgZGF0ZSBvZiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5zbG90TWluVGltZSksXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5cbi8vIHBvdGVudGlhbCBuaWNlIHZhbHVlcyBmb3IgdGhlIHNsb3QtZHVyYXRpb24gYW5kIGludGVydmFsLWR1cmF0aW9uXG4vLyBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3RcbmNvbnN0IFNUT0NLX1NVQl9EVVJBVElPTlMgPSBbXG4gICAgeyBob3VyczogMSB9LFxuICAgIHsgbWludXRlczogMzAgfSxcbiAgICB7IG1pbnV0ZXM6IDE1IH0sXG4gICAgeyBzZWNvbmRzOiAzMCB9LFxuICAgIHsgc2Vjb25kczogMTUgfSxcbl07XG5mdW5jdGlvbiBidWlsZFNsYXRNZXRhcyhzbG90TWluVGltZSwgc2xvdE1heFRpbWUsIGV4cGxpY2l0TGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uLCBkYXRlRW52KSB7XG4gICAgbGV0IGRheVN0YXJ0ID0gbmV3IERhdGUoMCk7XG4gICAgbGV0IHNsYXRUaW1lID0gc2xvdE1pblRpbWU7XG4gICAgbGV0IHNsYXRJdGVyYXRvciA9IGNyZWF0ZUR1cmF0aW9uKDApO1xuICAgIGxldCBsYWJlbEludGVydmFsID0gZXhwbGljaXRMYWJlbEludGVydmFsIHx8IGNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XG4gICAgbGV0IG1ldGFzID0gW107XG4gICAgd2hpbGUgKGFzUm91Z2hNcyhzbGF0VGltZSkgPCBhc1JvdWdoTXMoc2xvdE1heFRpbWUpKSB7XG4gICAgICAgIGxldCBkYXRlID0gZGF0ZUVudi5hZGQoZGF5U3RhcnQsIHNsYXRUaW1lKTtcbiAgICAgICAgbGV0IGlzTGFiZWxlZCA9IHdob2xlRGl2aWRlRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgbGFiZWxJbnRlcnZhbCkgIT09IG51bGw7XG4gICAgICAgIG1ldGFzLnB1c2goe1xuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIHRpbWU6IHNsYXRUaW1lLFxuICAgICAgICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBpc29UaW1lU3RyOiBmb3JtYXRJc29UaW1lU3RyaW5nKGRhdGUpLFxuICAgICAgICAgICAgaXNMYWJlbGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgc2xhdFRpbWUgPSBhZGREdXJhdGlvbnMoc2xhdFRpbWUsIHNsb3REdXJhdGlvbik7XG4gICAgICAgIHNsYXRJdGVyYXRvciA9IGFkZER1cmF0aW9ucyhzbGF0SXRlcmF0b3IsIHNsb3REdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBtZXRhcztcbn1cbi8vIENvbXB1dGVzIGFuIGF1dG9tYXRpYyB2YWx1ZSBmb3Igc2xvdExhYmVsSW50ZXJ2YWxcbmZ1bmN0aW9uIGNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbikge1xuICAgIGxldCBpO1xuICAgIGxldCBsYWJlbEludGVydmFsO1xuICAgIGxldCBzbG90c1BlckxhYmVsO1xuICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0b2NrIGxhYmVsIGludGVydmFsIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHNsb3RzLXBlci1sYWJlbFxuICAgIGZvciAoaSA9IFNUT0NLX1NVQl9EVVJBVElPTlMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgbGFiZWxJbnRlcnZhbCA9IGNyZWF0ZUR1cmF0aW9uKFNUT0NLX1NVQl9EVVJBVElPTlNbaV0pO1xuICAgICAgICBzbG90c1BlckxhYmVsID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMobGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcbiAgICAgICAgaWYgKHNsb3RzUGVyTGFiZWwgIT09IG51bGwgJiYgc2xvdHNQZXJMYWJlbCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbEludGVydmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90RHVyYXRpb247IC8vIGZhbGwgYmFja1xufVxuXG5jbGFzcyBEYXlUaW1lQ29sc1ZpZXcgZXh0ZW5kcyBUaW1lQ29sc1ZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkVGltZUNvbHNNb2RlbCA9IG1lbW9pemUoYnVpbGRUaW1lQ29sc01vZGVsKTtcbiAgICAgICAgdGhpcy5idWlsZFNsYXRNZXRhcyA9IG1lbW9pemUoYnVpbGRTbGF0TWV0YXMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYsIGRhdGVQcm9maWxlR2VuZXJhdG9yIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZFRpbWVDb2xzTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB0aGlzLmFsbERheVNwbGl0dGVyLnNwbGl0UHJvcHMocHJvcHMpO1xuICAgICAgICBsZXQgc2xhdE1ldGFzID0gdGhpcy5idWlsZFNsYXRNZXRhcyhkYXRlUHJvZmlsZS5zbG90TWluVGltZSwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUsIG9wdGlvbnMuc2xvdExhYmVsSW50ZXJ2YWwsIG9wdGlvbnMuc2xvdER1cmF0aW9uLCBkYXRlRW52KTtcbiAgICAgICAgbGV0IHsgZGF5TWluV2lkdGggfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBoYXNBdHRhY2hlZEF4aXMgPSAhZGF5TWluV2lkdGg7XG4gICAgICAgIGxldCBoYXNEZXRhY2hlZEF4aXMgPSBkYXlNaW5XaWR0aDtcbiAgICAgICAgbGV0IGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKGNyZWF0ZUVsZW1lbnQoRGF5SGVhZGVyLCB7IGRhdGVzOiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzOiB0cnVlLCByZW5kZXJJbnRybzogaGFzQXR0YWNoZWRBeGlzID8gdGhpcy5yZW5kZXJIZWFkQXhpcyA6IG51bGwgfSkpO1xuICAgICAgICBsZXQgYWxsRGF5Q29udGVudCA9IChvcHRpb25zLmFsbERheVNsb3QgIT09IGZhbHNlKSAmJiAoKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KERheVRhYmxlLCBPYmplY3QuYXNzaWduKHt9LCBzcGxpdFByb3BzLmFsbERheSwgeyBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIG5leHREYXlUaHJlc2hvbGQ6IG9wdGlvbnMubmV4dERheVRocmVzaG9sZCwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBjb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHJlbmRlclJvd0ludHJvOiBoYXNBdHRhY2hlZEF4aXMgPyB0aGlzLnJlbmRlclRhYmxlUm93QXhpcyA6IG51bGwsIHNob3dXZWVrTnVtYmVyczogZmFsc2UsIGV4cGFuZFJvd3M6IGZhbHNlLCBoZWFkZXJBbGlnbkVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0sIHRoaXMuZ2V0QWxsRGF5TWF4RXZlbnRQcm9wcygpKSkpKTtcbiAgICAgICAgbGV0IHRpbWVHcmlkQ29udGVudCA9IChjb250ZW50QXJnKSA9PiAoY3JlYXRlRWxlbWVudChEYXlUaW1lQ29scywgT2JqZWN0LmFzc2lnbih7fSwgc3BsaXRQcm9wcy50aW1lZCwgeyBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGF4aXM6IGhhc0F0dGFjaGVkQXhpcywgc2xvdER1cmF0aW9uOiBvcHRpb25zLnNsb3REdXJhdGlvbiwgc2xhdE1ldGFzOiBzbGF0TWV0YXMsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgdGFibGVDb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIG9uU2xhdENvb3JkczogdGhpcy5oYW5kbGVTbGF0Q29vcmRzLCBleHBhbmRSb3dzOiBjb250ZW50QXJnLmV4cGFuZFJvd3MsIG9uU2Nyb2xsVG9wUmVxdWVzdDogdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0IH0pKSk7XG4gICAgICAgIHJldHVybiBoYXNEZXRhY2hlZEF4aXNcbiAgICAgICAgICAgID8gdGhpcy5yZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlckNvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVHcmlkQ29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIGRheU1pbldpZHRoLCBzbGF0TWV0YXMsIHRoaXMuc3RhdGUuc2xhdENvb3JkcylcbiAgICAgICAgICAgIDogdGhpcy5yZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyQ29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUdyaWRDb250ZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFRpbWVDb2xzTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRheVNlcmllcyA9IG5ldyBEYXlTZXJpZXNNb2RlbChkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgIHJldHVybiBuZXcgRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIGZhbHNlKTtcbn1cblxudmFyIGNzc18yNDh6ID0gXCIuZmMtdi1ldmVudHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWV2ZW50LWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7ZGlzcGxheTpibG9ja30uZmMtdi1ldmVudCAuZmMtZXZlbnQtbWFpbntjb2xvcjp2YXIoLS1mYy1ldmVudC10ZXh0LWNvbG9yKTtoZWlnaHQ6MTAwJX0uZmMtdi1ldmVudCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2hlaWdodDoxMDAlfS5mYy12LWV2ZW50IC5mYy1ldmVudC10aW1le2ZsZXgtZ3JvdzowO2ZsZXgtc2hyaW5rOjA7bWF4LWhlaWdodDoxMDAlO292ZXJmbG93OmhpZGRlbn0uZmMtdi1ldmVudCAuZmMtZXZlbnQtdGl0bGUtY29udGFpbmVye2ZsZXgtZ3JvdzoxO2ZsZXgtc2hyaW5rOjE7bWluLWhlaWdodDowfS5mYy12LWV2ZW50IC5mYy1ldmVudC10aXRsZXtib3R0b206MDttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuO3RvcDowfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc3RhcnQpe2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3Atd2lkdGg6MH0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS13aWR0aDowfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZXtsZWZ0Oi0xMHB4O3JpZ2h0Oi0xMHB4fS5mYy12LWV2ZW50IC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0e2N1cnNvcjpuLXJlc2l6ZX0uZmMtdi1ldmVudCAuZmMtZXZlbnQtcmVzaXplci1lbmR7Y3Vyc29yOnMtcmVzaXplfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVye2hlaWdodDp2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcyk7bGVmdDowO3JpZ2h0OjB9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7dG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpLy0yKX0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1lbmR7Ym90dG9tOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplcntsZWZ0OjUwJTttYXJnaW4tbGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKS8tMil9LmZjLXYtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7dG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmR7Ym90dG9tOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMgLmZjLXRpbWVncmlkIC5mYy1kYXlncmlkLWJvZHl7ei1pbmRleDoyfS5mYyAuZmMtdGltZWdyaWQtZGl2aWRlcntwYWRkaW5nOjAgMCAycHh9LmZjIC5mYy10aW1lZ3JpZC1ib2R5e21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjF9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWNodW5re3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtdGltZWdyaWQtYXhpcy1jaHVuaz50YWJsZSwuZmMgLmZjLXRpbWVncmlkLXNsb3Rze3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLXNsb3R7Ym9yZGVyLWJvdHRvbTowO2hlaWdodDoxLjVlbX0uZmMgLmZjLXRpbWVncmlkLXNsb3Q6ZW1wdHk6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFwwMGEwXFxcIn0uZmMgLmZjLXRpbWVncmlkLXNsb3QtbWlub3J7Ym9yZGVyLXRvcC1zdHlsZTpkb3R0ZWR9LmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb257ZGlzcGxheTppbmxpbmUtYmxvY2s7d2hpdGUtc3BhY2U6bm93cmFwfS5mYyAuZmMtdGltZWdyaWQtc2xvdC1sYWJlbHt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWN1c2hpb24sLmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb257cGFkZGluZzowIDRweH0uZmMgLmZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZXthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZDtvdmVyZmxvdzpoaWRkZW59LmZjIC5mYy10aW1lZ3JpZC1heGlzLWN1c2hpb257ZmxleC1zaHJpbms6MDttYXgtd2lkdGg6NjBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1mcmFtZXt0ZXh0LWFsaWduOnJpZ2h0fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1le3RleHQtYWxpZ246bGVmdH0uZmMtbGlxdWlkLWhhY2sgLmZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlke2JvdHRvbTowO2hlaWdodDphdXRvO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtdGltZWdyaWQtY29sLmZjLWRheS10b2RheXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLXRvZGF5LWJnLWNvbG9yKX0uZmMgLmZjLXRpbWVncmlkLWNvbC1mcmFtZXttaW4taGVpZ2h0OjEwMCU7cG9zaXRpb246cmVsYXRpdmV9LmZjLW1lZGlhLXNjcmVlbi5mYy1saXF1aWQtaGFjayAuZmMtdGltZWdyaWQtY29sLWZyYW1le2JvdHRvbTowO2hlaWdodDphdXRvO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLWNvbHN7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29scz50YWJsZXtoZWlnaHQ6MTAwJX0uZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2wtYmcsLmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29sLWV2ZW50cywuZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lcntsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZ3t6LWluZGV4OjJ9LmZjIC5mYy10aW1lZ3JpZC1jb2wtYmcgLmZjLW5vbi1idXNpbmVzc3t6LWluZGV4OjF9LmZjIC5mYy10aW1lZ3JpZC1jb2wtYmcgLmZjLWJnLWV2ZW50e3otaW5kZXg6Mn0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtaGlnaGxpZ2h0e3otaW5kZXg6M30uZmMgLmZjLXRpbWVncmlkLWJnLWhhcm5lc3N7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmZjIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze3otaW5kZXg6M30uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVye2JvdHRvbTowO292ZXJmbG93OmhpZGRlbn0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdGltZWdyaWQtY29sLWV2ZW50c3ttYXJnaW46MCAyLjUlIDAgMnB4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze21hcmdpbjowIDJweCAwIDIuNSV9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3N7cG9zaXRpb246YWJzb2x1dGV9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3M+LmZjLXRpbWVncmlkLWV2ZW50e2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzLWluc2V0IC5mYy10aW1lZ3JpZC1ldmVudCwuZmMtdGltZWdyaWQtZXZlbnQuZmMtZXZlbnQtbWlycm9yLC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7Ym94LXNoYWRvdzowIDAgMCAxcHggdmFyKC0tZmMtcGFnZS1iZy1jb2xvcil9LmZjLXRpbWVncmlkLWV2ZW50LC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7Ym9yZGVyLXJhZGl1czozcHg7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSl9LmZjLXRpbWVncmlkLWV2ZW50e21hcmdpbi1ib3R0b206MXB4fS5mYy10aW1lZ3JpZC1ldmVudCAuZmMtZXZlbnQtbWFpbntwYWRkaW5nOjFweCAxcHggMH0uZmMtdGltZWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7bWFyZ2luLWJvdHRvbToxcHg7d2hpdGUtc3BhY2U6bm93cmFwfS5mYy10aW1lZ3JpZC1ldmVudC1zaG9ydCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtmbGV4LWRpcmVjdGlvbjpyb3c7b3ZlcmZsb3c6aGlkZGVufS5mYy10aW1lZ3JpZC1ldmVudC1zaG9ydCAuZmMtZXZlbnQtdGltZTphZnRlcntjb250ZW50OlxcXCJcXFxcMDBhMC1cXFxcMDBhMFxcXCJ9LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC10aXRsZXtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKX0uZmMtdGltZWdyaWQtbW9yZS1saW5re2JhY2tncm91bmQ6dmFyKC0tZmMtbW9yZS1saW5rLWJnLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1tb3JlLWxpbmstdGV4dC1jb2xvcik7Y3Vyc29yOnBvaW50ZXI7bWFyZ2luLWJvdHRvbToxcHg7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5fS5mYy10aW1lZ3JpZC1tb3JlLWxpbmstaW5uZXJ7cGFkZGluZzozcHggMnB4O3RvcDowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7cmlnaHQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdGltZWdyaWQtbW9yZS1saW5re2xlZnQ6MH0uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3csLmZjIC5mYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWxpbmV7cG9pbnRlci1ldmVudHM6bm9uZX0uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZXtib3JkZXItY29sb3I6dmFyKC0tZmMtbm93LWluZGljYXRvci1jb2xvcik7Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci13aWR0aDoxcHggMCAwO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3otaW5kZXg6NH0uZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLW5vdy1pbmRpY2F0b3ItY29sb3IpO2JvcmRlci1zdHlsZTpzb2xpZDttYXJnaW4tdG9wOi01cHg7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93e2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItd2lkdGg6NXB4IDAgNXB4IDZweDtsZWZ0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci13aWR0aDo1cHggNnB4IDVweCAwO3JpZ2h0OjB9XCI7XG5pbmplY3RTdHlsZXMoY3NzXzI0OHopO1xuXG5leHBvcnQgeyBEYXlUaW1lQ29scywgRGF5VGltZUNvbHNTbGljZXIsIERheVRpbWVDb2xzVmlldywgVGltZUNvbHMsIFRpbWVDb2xzU2xhdHNDb29yZHMsIFRpbWVDb2xzVmlldywgYnVpbGREYXlSYW5nZXMsIGJ1aWxkU2xhdE1ldGFzLCBidWlsZFRpbWVDb2xzTW9kZWwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@fullcalendar+timegrid@6.1.18_@fullcalendar+core@6.1.18/node_modules/@fullcalendar/timegrid/internal.js\n");

/***/ })

};
;